# 3_voxelization_with_dem.py
# Modified version that incorporates DEM elevation data
import argparse
from pathlib import Path
import math
import pickle

import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon, Point
from shapely import affinity
import shapely
import numpy as np
import trimesh
from trimesh import boolean
import re
from scipy.interpolate import griddata

def _make_valid(geom):
    """
    Make geometry valid using shapely's make_valid or buffer(0) as fallback.
    """
    try:
        from shapely.validation import make_valid
        return make_valid(geom)
    except Exception:
        try:
            return geom.buffer(0)
        except Exception:
            return None


def _to_iter_polygons(geom):
    if geom is None:
        return []
    if isinstance(geom, Polygon):
        return [geom]
    if isinstance(geom, MultiPolygon):
        return [p for p in geom.geoms if isinstance(p, Polygon)]
    return []


def _safe_float(x):
    try:
        if x is None:
            return None
        v = float(x)
        if math.isnan(v):
            return None
        return v
    except Exception:
        return None


def load_dem_from_pkl(pkl_path: Path):
    """
    Load DEM data from pkl file generated by 1_buildBC_with_dem.py.
    Returns: (dem_grid, x_grid, y_grid, base_height) or None if file doesn't exist.
    """
    if not pkl_path.exists():
        return None

    try:
        with open(pkl_path, 'rb') as f:
            dem_data = pickle.load(f)

        print(f"[INFO] Loaded DEM data from pkl: {pkl_path}")
        print(f"[INFO] DEM grid shape: {dem_data['dem_grid'].shape}")
        print(f"[INFO] DEM elevation difference range: {dem_data['dem_grid'].min():.2f}m to {dem_data['dem_grid'].max():.2f}m")

        return dem_data
    except Exception as e:
        print(f"[WARN] Failed to load DEM pkl: {e}")
        return None


def convert_pkl_dem_to_points(dem_data):
    """
    Convert pkl DEM grid data to point cloud format for compatibility with existing functions.
    Returns: (points_xy, elevations) where points_xy is Nx2 array in absolute UTM coordinates and elevations is N array.
    """
    dem_grid = dem_data['dem_grid']  # (ny, nx) elevation difference array
    x_grid = dem_data['x_grid']      # 1D x coordinates (relative, 0 to x_max)
    y_grid = dem_data['y_grid']      # 1D y coordinates (relative, 0 to y_max)
    x_min = dem_data['x_min']        # Absolute UTM x minimum
    y_min = dem_data['y_min']        # Absolute UTM y minimum

    # Create meshgrid in relative coordinates
    X, Y = np.meshgrid(x_grid, y_grid, indexing='xy')

    # Convert to absolute UTM coordinates
    X_abs = X + x_min
    Y_abs = Y + y_min

    # Flatten to point cloud
    points_xy = np.column_stack([X_abs.ravel(), Y_abs.ravel()])
    elevations = dem_grid.ravel()

    print(f"[INFO] Converted DEM grid to {len(elevations)} points in absolute UTM coordinates")

    return points_xy, elevations


def load_dem_data(dem_shp_path: Path, work_crs):
    """
    Load DEM elevation data from shapefile and prepare for interpolation.
    Returns: (points_xy, elevations) where points_xy is Nx2 array and elevations is N array
    """
    print(f"[INFO] Loading DEM data from: {dem_shp_path}")
    dem_gdf = gpd.read_file(dem_shp_path)
    
    if dem_gdf.empty:
        print("[WARN] DEM shapefile is empty, will use flat terrain")
        return None, None
    
    # Force geometries to 2D before reprojection to avoid Z-coordinate issues
    print("[INFO] Ensuring DEM geometries are 2D...")
    from shapely.ops import transform
    def force_2d(geom):
        """Force geometry to 2D by dropping Z coordinates"""
        if geom is None:
            return None
        return transform(lambda x, y, z=None: (x, y), geom)

    dem_gdf['geometry'] = dem_gdf['geometry'].apply(force_2d)

    # Reproject to working CRS if needed
    if dem_gdf.crs != work_crs:
        print(f"[INFO] Reprojecting DEM from {dem_gdf.crs} to {work_crs}")
        dem_gdf = dem_gdf.to_crs(work_crs)
    
    # Extract elevation values and centroids
    elevation_col = None
    for col in ['elevation', 'Elevation', 'ELEVATION', 'height', 'Height', 'z', 'Z']:
        if col in dem_gdf.columns:
            elevation_col = col
            break
    
    if elevation_col is None:
        print("[WARN] No elevation column found in DEM, will use flat terrain")
        return None, None
    
    print(f"[INFO] Using elevation column: {elevation_col}")
    
    # Get centroids and elevations
    points = []
    elevations = []
    for idx, row in dem_gdf.iterrows():
        geom = row.geometry
        if geom is None or geom.is_empty:
            continue
        elev = _safe_float(row[elevation_col])
        if elev is None:
            continue
        
        # Use centroid as representative point
        centroid = geom.centroid
        points.append([centroid.x, centroid.y])
        elevations.append(elev)
    
    if not points:
        print("[WARN] No valid DEM points found, will use flat terrain")
        return None, None
    
    points_xy = np.array(points)
    elevations = np.array(elevations)

    print(f"[INFO] Loaded {len(elevations)} DEM points")
    print(f"[INFO] Original elevation range (sea level): {elevations.min():.2f} to {elevations.max():.2f} meters")

    # Shift all elevations so minimum becomes 0 (datum adjustment)
    # This converts from sea level to relative elevation
    min_elev = elevations.min()
    elevations = elevations - min_elev

    print(f"[INFO] Adjusted to datum (lowest point = 0): {elevations.min():.2f} to {elevations.max():.2f} meters")
    print(f"[INFO] Datum offset applied: {min_elev:.2f}m")

    return points_xy, elevations


def create_elevation_lookup_grid(base_poly, dem_points, dem_elevations, grid_resolution=10.0, elevation_scale=1.0, smooth_sigma=1.0, idw_power=2.0, idw_neighbors=12):
    """
    Create a fast lookup grid for elevation queries.
    This is much faster than calling griddata() for each building.

    NOTE: dem_elevations should already be adjusted to datum (min=0)

    Args:
        base_poly: Base polygon boundary
        dem_points: Nx2 array of DEM point coordinates
        dem_elevations: N array of elevation values (already adjusted to datum)
        grid_resolution: Grid spacing in meters (smaller = more accurate but slower)
        elevation_scale: Scale factor for elevation differences
        smooth_sigma: Gaussian smoothing strength
        idw_power: IDW power parameter
        idw_neighbors: Number of nearest neighbors for IDW

    Returns:
        (X, Y, Z) grid arrays for fast bilinear interpolation
    """
    if dem_points is None or dem_elevations is None:
        return None, None, None

    print(f"[INFO] Creating elevation lookup grid (resolution: {grid_resolution}m)...")

    # Get bounds
    minx, miny, maxx, maxy = base_poly.bounds

    # Create grid
    nx = int((maxx - minx) / grid_resolution) + 1
    ny = int((maxy - miny) / grid_resolution) + 1

    x = np.linspace(minx, maxx, nx)
    y = np.linspace(miny, maxy, ny)
    X, Y = np.meshgrid(x, y)

    # Interpolate elevations on grid using IDW (do this once!)
    points_grid = np.column_stack([X.ravel(), Y.ravel()])

    from scipy.spatial import cKDTree

    # Build KD-tree for fast nearest neighbor search
    tree = cKDTree(dem_points)

    # IDW parameters
    power = idw_power
    n_neighbors = idw_neighbors

    # Query nearest neighbors
    distances, indices = tree.query(points_grid, k=n_neighbors)
    distances = np.maximum(distances, 1e-10)

    # Calculate IDW weights
    weights = 1.0 / (distances ** power)
    weights_sum = weights.sum(axis=1, keepdims=True)
    weights_normalized = weights / weights_sum

    # Interpolate elevations
    Z = np.sum(weights_normalized * dem_elevations[indices], axis=1)

    Z = Z.reshape(ny, nx)

    # Apply Gaussian smoothing (lighter than terrain mesh)
    if smooth_sigma > 0:
        from scipy.ndimage import gaussian_filter
        Z = gaussian_filter(Z, sigma=smooth_sigma * 0.5)  # Half the terrain smoothing

    # Ensure minimum is at least 0 (in case smoothing created negative values)
    if Z.min() < 0:
        Z = np.maximum(Z, 0.0)

    # Apply elevation scale
    if elevation_scale != 1.0:
        Z = Z * elevation_scale

    print(f"[INFO] Elevation lookup grid created: {nx} x {ny} = {nx*ny} points")
    print(f"[INFO] Lookup grid elevation range: {Z.min():.2f} to {Z.max():.2f} meters")

    return X, Y, Z


def interpolate_elevation_fast(x, y, X_grid, Y_grid, Z_grid):
    """
    Fast elevation lookup using pre-computed grid and bilinear interpolation.

    Args:
        x, y: Query coordinates
        X_grid, Y_grid, Z_grid: Pre-computed elevation grid

    Returns:
        Interpolated elevation value
    """
    if X_grid is None or Y_grid is None or Z_grid is None:
        return 0.0

    try:
        # Get grid parameters
        ny, nx = Z_grid.shape
        x_min, x_max = X_grid[0, 0], X_grid[0, -1]
        y_min, y_max = Y_grid[0, 0], Y_grid[-1, 0]

        # Check bounds
        if x < x_min or x > x_max or y < y_min or y > y_max:
            return 0.0

        # Find grid cell
        dx = (x_max - x_min) / (nx - 1)
        dy = (y_max - y_min) / (ny - 1)

        i = int((x - x_min) / dx)
        j = int((y - y_min) / dy)

        # Clamp to valid range
        i = max(0, min(i, nx - 2))
        j = max(0, min(j, ny - 2))

        # Bilinear interpolation
        x0, x1 = X_grid[j, i], X_grid[j, i+1]
        y0, y1 = Y_grid[j, i], Y_grid[j+1, i]

        z00 = Z_grid[j, i]
        z10 = Z_grid[j, i+1]
        z01 = Z_grid[j+1, i]
        z11 = Z_grid[j+1, i+1]

        # Interpolation weights
        wx = (x - x0) / (x1 - x0) if x1 != x0 else 0.0
        wy = (y - y0) / (y1 - y0) if y1 != y0 else 0.0

        # Bilinear interpolation
        z = (1 - wx) * (1 - wy) * z00 + \
            wx * (1 - wy) * z10 + \
            (1 - wx) * wy * z01 + \
            wx * wy * z11

        return float(z)
    except Exception:
        return 0.0


def create_terrain_mesh(base_poly: Polygon, dem_points, dem_elevations, grid_resolution=50, elevation_scale=1.0, smooth_sigma=1.0, idw_power=2.0, idw_neighbors=12, base_height=50.0, proj_temp: Path = Path("./proj_temp")) -> trimesh.Trimesh:
    """
    Create a terrain mesh from DEM data within the base polygon.
    The terrain sits on top of the base layer (at z=base_height).

    NOTE: dem_elevations should already be adjusted so minimum = 0 (datum adjustment done in load_dem_data)

    Args:
        base_poly: Base polygon boundary
        dem_points: Nx2 array of DEM point coordinates
        dem_elevations: N array of elevation values (already adjusted to datum)
        grid_resolution: Grid spacing in meters
        elevation_scale: Scale factor for elevation differences (for visualization)
        smooth_sigma: Gaussian smoothing strength (0=no smoothing)
        idw_power: IDW power parameter
        idw_neighbors: Number of nearest neighbors for IDW
        base_height: Height of base layer (terrain starts from this height)

    Returns:
        terrain_mesh: trimesh object representing the terrain surface
    """
    if dem_points is None or dem_elevations is None:
        print("[INFO] No DEM data, creating flat base")
        return None

    print(f"[INFO] Creating terrain mesh with resolution {grid_resolution}m")

    # Get bounds of base polygon
    minx, miny, maxx, maxy = base_poly.bounds

    # Create grid
    nx = int((maxx - minx) / grid_resolution) + 1
    ny = int((maxy - miny) / grid_resolution) + 1

    print(f"[INFO] Grid size: {nx} x {ny} = {nx*ny} points")

    x = np.linspace(minx, maxx, nx)
    y = np.linspace(miny, maxy, ny)
    X, Y = np.meshgrid(x, y)

    # Interpolate elevations on grid
    points_grid = np.column_stack([X.ravel(), Y.ravel()])

    # Use Inverse Distance Weighting (IDW) interpolation
    # IDW is more stable and doesn't extrapolate beyond data range
    print("[INFO] Interpolating elevations using Inverse Distance Weighting (IDW)...")

    from scipy.spatial import cKDTree

    # Build KD-tree for fast nearest neighbor search
    tree = cKDTree(dem_points)

    # IDW parameters
    power = idw_power  # Power parameter (higher = more weight to closer points)
    n_neighbors = idw_neighbors  # Number of nearest neighbors to use

    # Query nearest neighbors for all grid points
    distances, indices = tree.query(points_grid, k=n_neighbors)

    # Avoid division by zero for points exactly on DEM points
    distances = np.maximum(distances, 1e-10)

    # Calculate IDW weights
    weights = 1.0 / (distances ** power)
    weights_sum = weights.sum(axis=1, keepdims=True)
    weights_normalized = weights / weights_sum

    # Interpolate elevations
    Z = np.sum(weights_normalized * dem_elevations[indices], axis=1)

    print(f"[INFO] IDW interpolation complete using {n_neighbors} nearest neighbors")

    Z = Z.reshape(ny, nx)

    # Apply Gaussian smoothing for even smoother terrain
    if smooth_sigma > 0:
        print(f"[INFO] Applying Gaussian smoothing (sigma={smooth_sigma:.1f}) for terrain smoothness...")
        from scipy.ndimage import gaussian_filter
        Z = gaussian_filter(Z, sigma=smooth_sigma)
    else:
        print("[INFO] Smoothing disabled (sigma=0)")

    print(f"[INFO] Interpolated elevation range: {Z.min():.2f} to {Z.max():.2f} meters")

    # Ensure minimum is at least 0 (in case smoothing created negative values)
    if Z.min() < 0:
        print(f"[WARN] Smoothing created negative values (min={Z.min():.2f}m), clipping to 0")
        Z = np.maximum(Z, 0.0)

    # Apply elevation scale (for visualization/testing)
    if elevation_scale != 1.0:
        print(f"[INFO] Applying elevation scale factor: {elevation_scale}x")
        Z = Z * elevation_scale

    print(f"[INFO] Final terrain elevation range: {Z.min():.2f} to {Z.max():.2f} meters")

    # Export interpolated DEM to CSV
    csv_path = proj_temp / "interpolated_dem.csv"
    print(f"[INFO] Exporting interpolated DEM to {csv_path}")
    with open(csv_path, 'w') as f:
        f.write("x,y,elevation\n")
        for i in range(ny):
            for j in range(nx):
                f.write(f"{X[i, j]:.3f},{Y[i, j]:.3f},{Z[i, j]:.3f}\n")
    print(f"[INFO] Exported {nx * ny} interpolated elevation points to {csv_path}")

    # Verify the minimum is now ~0
    actual_min = Z.min()
    if abs(actual_min) > 0.01:
        print(f"[WARN] Minimum elevation is {actual_min:.2f}m, expected ~0.00m")

    # Create a solid terrain mesh (from base_height to terrain surface)
    # This sits on top of the base layer

    # Create top surface vertices (terrain surface on top of base layer)
    vertices_top = []
    for i in range(ny):
        for j in range(nx):
            vertices_top.append([X[i, j], Y[i, j], base_height + Z[i, j]])

    # Create bottom surface vertices (at base_height, top of base layer)
    vertices_bottom = []
    for i in range(ny):
        for j in range(nx):
            vertices_bottom.append([X[i, j], Y[i, j], base_height])

    vertices = np.vstack([vertices_top, vertices_bottom])

    # Create faces
    faces = []
    n_top = ny * nx

    # Top surface triangles
    for i in range(ny - 1):
        for j in range(nx - 1):
            v0 = i * nx + j
            v1 = i * nx + (j + 1)
            v2 = (i + 1) * nx + j
            v3 = (i + 1) * nx + (j + 1)

            faces.append([v0, v1, v2])
            faces.append([v1, v3, v2])

    # Bottom surface triangles (reversed winding)
    for i in range(ny - 1):
        for j in range(nx - 1):
            v0 = n_top + i * nx + j
            v1 = n_top + i * nx + (j + 1)
            v2 = n_top + (i + 1) * nx + j
            v3 = n_top + (i + 1) * nx + (j + 1)

            faces.append([v0, v2, v1])
            faces.append([v1, v2, v3])

    # Side faces (connect top and bottom edges)
    # Left edge (j=0)
    for i in range(ny - 1):
        v0_top = i * nx
        v1_top = (i + 1) * nx
        v0_bot = n_top + i * nx
        v1_bot = n_top + (i + 1) * nx
        faces.append([v0_top, v1_top, v0_bot])
        faces.append([v1_top, v1_bot, v0_bot])

    # Right edge (j=nx-1)
    for i in range(ny - 1):
        v0_top = i * nx + (nx - 1)
        v1_top = (i + 1) * nx + (nx - 1)
        v0_bot = n_top + i * nx + (nx - 1)
        v1_bot = n_top + (i + 1) * nx + (nx - 1)
        faces.append([v0_top, v0_bot, v1_top])
        faces.append([v1_top, v0_bot, v1_bot])

    # Front edge (i=0)
    for j in range(nx - 1):
        v0_top = j
        v1_top = j + 1
        v0_bot = n_top + j
        v1_bot = n_top + j + 1
        faces.append([v0_top, v0_bot, v1_top])
        faces.append([v1_top, v0_bot, v1_bot])

    # Back edge (i=ny-1)
    for j in range(nx - 1):
        v0_top = (ny - 1) * nx + j
        v1_top = (ny - 1) * nx + j + 1
        v0_bot = n_top + (ny - 1) * nx + j
        v1_bot = n_top + (ny - 1) * nx + j + 1
        faces.append([v0_top, v1_top, v0_bot])
        faces.append([v1_top, v1_bot, v0_bot])

    faces = np.array(faces)

    terrain_mesh = trimesh.Trimesh(vertices=vertices, faces=faces)

    print(f"[INFO] Terrain mesh created: {len(vertices)} vertices, {len(faces)} faces")
    print(f"[INFO] Terrain is a solid volume from z={base_height}m to terrain surface")

    return terrain_mesh


def extrude_polygon_to_mesh(poly: Polygon, height: float) -> trimesh.Trimesh:
    # Ensure the polygon is in 2D (ignore Z if present)
    def _ensure_2d_coords(coords):
        """Ensure coordinates are 2D"""
        return [(x, y) for x, y, *_ in coords] if len(coords[0]) > 2 else coords

    # Process exterior ring
    exterior_coords = list(poly.exterior.coords)
    exterior_2d = _ensure_2d_coords(exterior_coords)

    # Process interior rings (holes)
    holes_2d = []
    for interior in poly.interiors:
        interior_coords = list(interior.coords)
        interior_2d = _ensure_2d_coords(interior_coords)
        holes_2d.append(interior_2d)

    # Create 2D polygon
    if holes_2d:
        poly_2d = Polygon(exterior_2d, holes_2d)
    else:
        poly_2d = Polygon(exterior_2d)

    try:
        return trimesh.creation.extrude_polygon(poly_2d, height, engine="earcut")
    except Exception:
        try:
            return trimesh.creation.extrude_polygon(poly_2d, height, engine="triangle")
        except Exception as e:
            raise RuntimeError("No triangulation engine available, please install mapbox_earcut or triangle") from e


def _build_bbox_polygon_from_conf(conf_path) -> Polygon:
    """
    从给定的 conf 文件读取 cut_lon_manual 与 cut_lat_manual，构造经纬度 bbox 多边形。
    """
    conf_file = Path(conf_path).expanduser().resolve()
    if not conf_file.exists():
        raise FileNotFoundError(f"[ERROR] Configuration file not found: {conf_file}")
    txt = conf_file.read_text(encoding="utf-8", errors="ignore")

    m_lon = re.search(r"cut_lon_manual\s*=\s*\[([^\]]+)\]", txt)
    m_lat = re.search(r"cut_lat_manual\s*=\s*\[([^\]]+)\]", txt)
    if not (m_lon and m_lat):
        raise ValueError("conf 中未找到 cut_lon_manual/cut_lat_manual")

    lon_vals = [float(v.strip()) for v in m_lon.group(1).split(",")]
    lat_vals = [float(v.strip()) for v in m_lat.group(1).split(",")]
    minx, maxx = min(lon_vals), max(lon_vals)
    miny, maxy = min(lat_vals), max(lat_vals)

    ring = [(minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny)]
    return Polygon(ring)


def _project_geometry(geom: Polygon, target_crs) -> Polygon:
    """
    Project geometry to target CRS using GeoSeries's to_crs.
    """
    gs = gpd.GeoSeries([geom], crs="EPSG:4326")
    gs2 = gs.to_crs(target_crs)
    result = gs2.iloc[0]
    if isinstance(result, Polygon):
        return result
    else:
        raise RuntimeError(f"投影结果不是Polygon类型: {type(result)}")


def main():
    parser = argparse.ArgumentParser(
        description="读取建筑底面 Shapefile 和 DEM 数据，依据高度字段挤出并导出整体 STL。包含地形和建筑物。"
    )
    parser.add_argument(
        "conf",
        help="path to deck file"
    )
    parser.add_argument(
        "--height-field",
        default="auto",
        help="height field in shapefile, or 'auto' to detect (Height, Elevation, etc.). Default 'auto'"
    )
    parser.add_argument(
        "--min-height",
        type=float,
        default=0.0,
        help="minimum valid height in meters. Buildings with height less than this will be ignored. Default 0.0"
    )
    parser.add_argument(
        "--no-reproject",
        action="store_true",
        help="do not reproject shapefile to UTM, use original CRS"
    )
    parser.add_argument(
        "--dem-path",
        type=str,
        default=None,
        help="path to DEM shapefile. If not provided, will look for DEM folder in project home"
    )
    parser.add_argument(
        "--terrain-resolution",
        type=float,
        default=50.0,
        help="terrain mesh grid resolution in meters. Default 50.0"
    )
    parser.add_argument(
        "--max-buildings",
        type=int,
        default=None,
        help="maximum number of buildings to process (for testing). Default: process all buildings"
    )
    parser.add_argument(
        "--elevation-scale",
        type=float,
        default=1.0,
        help="scale factor for elevation differences (for visualization/testing). Default: 1.0"
    )
    parser.add_argument(
        "--smooth-sigma",
        type=float,
        default=1.0,
        help="Gaussian smoothing strength for terrain (0=no smoothing, 1=default, 2=very smooth). Default: 1.0"
    )
    parser.add_argument(
        "--idw-power",
        type=float,
        default=2.0,
        help="IDW power parameter (higher = more weight to closer points, 1-3 recommended). Default: 2.0"
    )
    parser.add_argument(
        "--idw-neighbors",
        type=int,
        default=12,
        help="Number of nearest neighbors for IDW interpolation. Default: 12"
    )
    parser.add_argument(
        "--base-height",
        type=float,
        default=50.0,
        help="Base layer height in meters (terrain sits on top of this). Default: 50.0"
    )

    args = parser.parse_args()
    print("[INFO] Parsed CLI arguments")

    conf_file = Path(args.conf).expanduser().resolve()
    if not conf_file.exists():
        raise FileNotFoundError(f"conf file not found: {conf_file}")
    project_home = conf_file.parent
    proj_temp = project_home / "proj_temp"
    proj_temp.mkdir(parents=True, exist_ok=True)

    txt_conf = conf_file.read_text(encoding="utf-8", errors="ignore")
    m_case = re.search(r"casename\s*=\s*([^\s]+)", txt_conf)
    if not m_case:
        raise RuntimeError("casename not found in conf")
    case_name = m_case.group(1)

    # Find building shapefile
    primary_shp = proj_temp / f"cutted_shp/{case_name}.shp"
    fallback_shp = proj_temp / f"{case_name}.shp"

    if primary_shp.exists():
        shp_path = primary_shp
    elif fallback_shp.exists():
        print(f"[WARN] Primary shapefile not found: {primary_shp.name}. Fallback to {fallback_shp.name}")
        shp_path = fallback_shp
    else:
        raise FileNotFoundError(f"Shapefile not found: {primary_shp} or {fallback_shp}")

    print(f"[INFO] Input Shapefile: {shp_path}")
    print(f"[INFO] Height field: {args.height_field}")
    print(f"[INFO] Min valid height: {args.min_height} m")

    combined_file = proj_temp / f"{case_name}_DEM.stl"

    print(f"[INFO] Reading features from file")
    gdf = gpd.read_file(shp_path)
    if len(gdf) == 0:
        raise RuntimeError("Shapefile has no features")
    print(f"[INFO] Read {len(gdf)} features")
    print(f"[INFO] Source CRS: {gdf.crs}")

    # Use fixed UTM CRS to match main.ipynb configuration (EPSG:32651)
    gdf_work = gdf.copy()
    if not args.no_reproject:
        try:
            if gdf_work.crs is not None:
                gdf_work = gdf_work.to_crs("EPSG:32651")
        except Exception:
            pass

    work_crs = gdf_work.crs
    print(f"[INFO] Working CRS (fixed to match main.ipynb): {work_crs}")

    # Try to load DEM data from pkl first (generated by 1_buildBC_with_dem.py)
    proj_temp = project_home / "proj_temp"
    dem_pkl_path = proj_temp / "dem_grid.pkl"
    dem_data_pkl = load_dem_from_pkl(dem_pkl_path)

    dem_points, dem_elevations = None, None
    use_pkl_dem = False

    if dem_data_pkl is not None:
        # Use DEM data from pkl
        print("[INFO] Using DEM data from pkl file (generated by 1_buildBC_with_dem.py)")
        use_pkl_dem = True
        # Convert grid to point cloud for compatibility with existing functions
        dem_points, dem_elevations = convert_pkl_dem_to_points(dem_data_pkl)
    else:
        # Fallback: Load DEM data from shapefile
        print("[INFO] No pkl file found, trying to load DEM from shapefile")
        if args.dem_path:
            dem_path = Path(args.dem_path)
        else:
            # Look for DEM folder in project home
            dem_folder = project_home / "DEM"
            if dem_folder.exists():
                dem_files = list(dem_folder.glob("*.shp"))
                if dem_files:
                    dem_path = dem_files[0]
                    print(f"[INFO] Auto-detected DEM file: {dem_path}")
                else:
                    print("[WARN] No DEM shapefile found in DEM folder")
                    dem_path = None
            else:
                print("[WARN] No DEM folder found")
                dem_path = None

        if dem_path and dem_path.exists():
            dem_points, dem_elevations = load_dem_data(dem_path, work_crs)
        else:
            print("[INFO] No DEM data available, will create flat terrain")

    # Auto-detect height field
    if args.height_field == "auto":
        height_candidates = ["Height", "Elevation", "height", "elevation", "HEIGHT", "ELEVATION"]
        height_field = None
        for candidate in height_candidates:
            if candidate in gdf_work.columns:
                height_field = candidate
                print(f"[INFO] Auto-detected height field: {height_field}")
                break
        if height_field is None:
            raise RuntimeError(f"Cannot auto-detect height field. Available fields: {list(gdf_work.columns)}")
        args.height_field = height_field
    else:
        print(f"[INFO] Using specified height field: {args.height_field}")

    # Build bbox and rotation
    bbox_ll = _build_bbox_polygon_from_conf(conf_file)
    print("[INFO] Built geographic bbox from conf.txt")
    if bbox_ll is None:
        raise RuntimeError("Cannot build lat-lon bbox")
    try:
        base_poly_proj = _project_geometry(bbox_ll, work_crs) if work_crs is not None else bbox_ll
    except Exception:
        minx, miny, maxx, maxy = gdf_work.total_bounds
        base_poly_proj = Polygon([(minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy)])
    print("[INFO] Projected bbox polygon into working CRS")

    # Estimate rotation angle
    coords = list(base_poly_proj.exterior.coords)
    if len(coords) < 2:
        raise RuntimeError("[ERROR] Base rectangle geometry is abnormal")
    x0, y0 = coords[0][0], coords[0][1]
    x1, y1 = coords[1][0], coords[1][1]
    dx, dy = x1 - x0, y1 - y0
    angle_rad = math.atan2(dy, dx)
    rotate_deg = - math.degrees(angle_rad)

    pivot = base_poly_proj.centroid
    pivot_xy = (pivot.x, pivot.y)
    print(f"[INFO] Estimated rotation: {rotate_deg:.6f} degrees")
    print(f"[INFO] Rotation pivot: ({pivot_xy[0]:.3f}, {pivot_xy[1]:.3f})")

    # Rotate base
    base_rot = affinity.rotate(base_poly_proj, rotate_deg, origin=pivot_xy, use_radians=False)
    print("[INFO] Rotated base rectangle")

    # Rotate DEM points if available
    if dem_points is not None:
        if use_pkl_dem:
            print("[INFO] Rotating DEM points from pkl (need to match building coordinate system)")
        else:
            print("[INFO] Rotating DEM points")
        dem_points_rot = []
        for pt in dem_points:
            x, y = pt
            # Apply rotation
            th = math.radians(rotate_deg)
            c = math.cos(th)
            s = math.sin(th)
            xr = c * (x - pivot_xy[0]) - s * (y - pivot_xy[1]) + pivot_xy[0]
            yr = s * (x - pivot_xy[0]) + c * (y - pivot_xy[1]) + pivot_xy[1]
            dem_points_rot.append([xr, yr])
        dem_points = np.array(dem_points_rot)

    # Rotate and filter buildings
    print("[INFO] Rotating building polygons and filtering by height")
    rotated_polygons = []
    heights = []
    for _, row in gdf_work.iterrows():
        geom = row.geometry
        if geom is None or geom.is_empty:
            continue
        h = _safe_float(row.get(args.height_field))
        if h is None or h <= args.min_height:
            continue
        geom_valid = _make_valid(geom)
        if geom_valid is None or geom_valid.is_empty:
            continue
        polys = _to_iter_polygons(geom_valid)
        if not polys:
            continue
        for poly in polys:
            try:
                poly_rot = affinity.rotate(poly, rotate_deg, origin=pivot_xy, use_radians=False)
                rotated_polygons.append(poly_rot)
                heights.append(h)
            except Exception:
                continue

    if not rotated_polygons:
        raise RuntimeError("[ERROR] No valid building polygons available")

    # Clip buildings to boundary
    print("[INFO] Clipping buildings to boundary box")
    clipped_polygons = []
    clipped_heights = []
    boundary_box = base_rot

    for poly, h in zip(rotated_polygons, heights):
        try:
            clipped = poly.intersection(boundary_box)
            if not clipped.is_empty and clipped.area > 0:
                if isinstance(clipped, Polygon):
                    clipped_polygons.append(clipped)
                    clipped_heights.append(h)
                elif isinstance(clipped, MultiPolygon):
                    for sub_poly in clipped.geoms:
                        if isinstance(sub_poly, Polygon) and sub_poly.area > 0:
                            clipped_polygons.append(sub_poly)
                            clipped_heights.append(h)
        except Exception:
            continue

    rotated_polygons = clipped_polygons
    heights = clipped_heights
    print(f"[INFO] Clipped buildings: {len(rotated_polygons)} polygons remaining")

    if heights:
        print(f"[INFO] Building height stats: min {min(heights):.3f}m, max {max(heights):.3f}m")

    # Limit number of buildings if specified (for testing)
    if args.max_buildings is not None and len(rotated_polygons) > args.max_buildings:
        print(f"[INFO] Limiting to first {args.max_buildings} buildings (--max-buildings parameter)")
        rotated_polygons = rotated_polygons[:args.max_buildings]
        heights = heights[:args.max_buildings]

    # Calculate translation to origin
    minx_all, miny_all = base_rot.bounds[0], base_rot.bounds[1]
    tx, ty = -minx_all, -miny_all

    base_final = affinity.translate(base_rot, xoff=tx, yoff=ty)
    print(f"[INFO] Translation offsets: dx {tx:.3f}, dy {ty:.3f}")

    shifted_polygons = [affinity.translate(p, xoff=tx, yoff=ty) for p in rotated_polygons]

    # Translate DEM points
    if dem_points is not None:
        dem_points[:, 0] += tx
        dem_points[:, 1] += ty

    # Create base layer (z=0 to z=base_height)
    print(f"[INFO] Creating base layer from z=0 to z={args.base_height}m")
    base_mesh = extrude_polygon_to_mesh(base_final, args.base_height)
    print("[INFO] Base layer created")

    # Create terrain mesh (sits on top of base layer)
    terrain_mesh = create_terrain_mesh(
        base_final,
        dem_points,
        dem_elevations,
        args.terrain_resolution,
        elevation_scale=args.elevation_scale,
        smooth_sigma=args.smooth_sigma,
        idw_power=args.idw_power,
        idw_neighbors=args.idw_neighbors,
        base_height=args.base_height,
        proj_temp=proj_temp
    )

    # Create fast elevation lookup grid for building placement
    # Use finer resolution (10m) for more accurate building base elevations
    # Note: dem_elevations are already adjusted to datum (min=0)
    X_elev_grid, Y_elev_grid, Z_elev_grid = create_elevation_lookup_grid(
        base_final,
        dem_points,
        dem_elevations,
        grid_resolution=10.0,
        elevation_scale=args.elevation_scale,
        smooth_sigma=args.smooth_sigma,
        idw_power=args.idw_power,
        idw_neighbors=args.idw_neighbors
    )

    # Report terrain statistics
    if terrain_mesh is not None:
        min_terrain_z = terrain_mesh.vertices[:, 2].min()
        max_terrain_z = terrain_mesh.vertices[:, 2].max()
        print(f"[INFO] Terrain layer elevation range: {min_terrain_z:.2f}m to {max_terrain_z:.2f}m")
        print(f"[INFO] Terrain relief: {max_terrain_z - min_terrain_z:.2f}m")

    # Generate building meshes
    building_meshes = []
    failed_count = 0
    building_base_elevations = []  # Track building base elevations for statistics

    total_buildings = len(shifted_polygons)
    print(f"[INFO] Extruding {total_buildings} buildings...")

    for i, (poly, h) in enumerate(zip(shifted_polygons, heights)):
        if h <= 0:
            continue
        try:
            # Get terrain elevation at all building footprint vertices
            # Use the MINIMUM elevation to ensure building doesn't float above terrain
            terrain_elevs = []
            for coord in poly.exterior.coords:
                # Handle both 2D and 3D coordinates
                x, y = coord[0], coord[1]
                elev = interpolate_elevation_fast(
                    x, y,
                    X_elev_grid, Y_elev_grid, Z_elev_grid
                )
                terrain_elevs.append(elev)

            # Use minimum elevation to prevent gaps (building sits on lowest point)
            min_terrain_elev = min(terrain_elevs) if terrain_elevs else 0.0

            # Building sits on: base_height + minimum_terrain_elevation
            base_elev = args.base_height + min_terrain_elev

            # Extrude building from terrain surface
            m = extrude_polygon_to_mesh(poly, h)
            m.apply_translation([0.0, 0.0, base_elev])
            building_meshes.append(m)
            building_base_elevations.append(base_elev)
        except Exception as e:
            failed_count += 1
            if failed_count <= 5:
                print(f"[WARN] Building {i} extrusion failed: {e}")
            continue

    if failed_count > 0:
        print(f"[WARN] Total {failed_count} buildings failed to extrude")

    print(f"[INFO] Extruded {len(building_meshes)} building meshes")

    if building_base_elevations:
        base_elev_array = np.array(building_base_elevations)
        print(f"[INFO] Building base elevation stats:")
        print(f"       Min: {base_elev_array.min():.2f}m, Max: {base_elev_array.max():.2f}m")
        print(f"       Mean: {base_elev_array.mean():.2f}m, Std: {base_elev_array.std():.2f}m")

    # Combine all layers: base + terrain + buildings
    meshes_to_combine = [base_mesh]
    if terrain_mesh is not None:
        meshes_to_combine.append(terrain_mesh)
    if building_meshes:
        meshes_to_combine.extend(building_meshes)

    if len(meshes_to_combine) == 1:
        print("[INFO] Only base layer, no terrain or buildings")
        final_mesh = base_mesh
    else:
        try:
            layer_names = ["base"]
            if terrain_mesh is not None:
                layer_names.append("terrain")
            if building_meshes:
                layer_names.append(f"{len(building_meshes)} buildings")
            print(f"[INFO] Combining layers: {', '.join(layer_names)}")
            final_mesh = trimesh.util.concatenate(meshes_to_combine)
            print("[INFO] Mesh combination succeeded")
        except Exception as e:
            print(f"[WARN] Mesh combination failed: {e}")
            final_mesh = trimesh.util.concatenate(meshes_to_combine)

    final_mesh.export(combined_file, file_type="stl")
    print(f"[INFO] Exported STL with terrain: {combined_file.resolve()}")

    # Report statistics
    minx, miny, maxx, maxy = base_final.bounds
    corners = [
        (minx, miny),
        (maxx, miny),
        (maxx, maxy),
        (minx, maxy)
    ]
    print("[RESULT] Base rectangle corners in meters")
    print(f"[RESULT] Lower left: ({corners[0][0]:.3f}, {corners[0][1]:.3f})")
    print(f"[RESULT] Lower right: ({corners[1][0]:.3f}, {corners[1][1]:.3f})")
    print(f"[RESULT] Upper right: ({corners[2][0]:.3f}, {corners[2][1]:.3f})")
    print(f"[RESULT] Upper left: ({corners[3][0]:.3f}, {corners[3][1]:.3f})")

    min_bounds, max_bounds = final_mesh.bounds
    zmin = float(min_bounds[2])
    zmax = float(max_bounds[2])
    print(f"[RESULT] STL Z range: min {zmin:.3f}m, max {zmax:.3f}m")
    print(f"[RESULT] Total height: {(zmax - zmin):.3f}m")


if __name__ == "__main__":
    main()


