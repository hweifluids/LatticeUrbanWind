# 3_voxelization.py
# Voxelization of buildings with terrain-aware base elevation based on cutted data.
import argparse
from pathlib import Path
import math
import pickle
import os
import sys
import concurrent.futures
import time


import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon, Point
from shapely import affinity
import shapely
import numpy as np
import trimesh
from trimesh import boolean
import re
from scipy.interpolate import griddata
from auto_UTM import get_utm_crs_from_conf_raw
from dem_tif_to_shp import ensure_dem_shp_from_tif

def _parse_base_height_from_conf_raw(conf_raw: str) -> float | None:
    """
    Parse base_height from conf raw text if present.
    Mirrors core/bridge_core/1_buildBC.py behavior.
    """
    if not conf_raw:
        return None
    m = re.search(r"base_height\s*=\s*([-+]?\d+(?:\.\d+)?(?:[eE][-+]?\d+)?)", conf_raw)
    if not m:
        return None
    try:
        v = float(m.group(1))
    except Exception:
        return None
    if (not math.isfinite(v)) or (v < 0.0):
        return None
    return v

def _make_valid(geom):
    """
    Make geometry valid using shapely's make_valid or buffer(0) as fallback.
    """
    try:
        from shapely.validation import make_valid
        return make_valid(geom)
    except Exception:
        try:
            return geom.buffer(0)
        except Exception:
            return None


def _to_iter_polygons(geom):
    if geom is None:
        return []
    if isinstance(geom, Polygon):
        return [geom]
    if isinstance(geom, MultiPolygon):
        return [p for p in geom.geoms if isinstance(p, Polygon)]
    return []


def _safe_float(x):
    try:
        if x is None:
            return None
        v = float(x)
        if math.isnan(v):
            return None
        return v
    except Exception:
        return None


def _rotate_points_xy(points_xy: np.ndarray, rotate_deg: float, pivot_xy):
    """
    Rotate Nx2 points around pivot by rotate_deg degrees (CCW positive).
    """
    if points_xy is None:
        return None
    if float(rotate_deg) == 0.0:
        return points_xy
    cx = float(pivot_xy[0])
    cy = float(pivot_xy[1])
    th = math.radians(float(rotate_deg))
    c = math.cos(th)
    s = math.sin(th)

    x = points_xy[:, 0] - cx
    y = points_xy[:, 1] - cy
    xr = c * x - s * y + cx
    yr = s * x + c * y + cy
    return np.column_stack([xr, yr])


def load_dem_from_pkl(pkl_path: Path):

    """
    Load DEM data from pkl file generated by 1_buildBC_with_dem.py.
    Returns: (dem_grid, x_grid, y_grid, base_height) or None if file doesn't exist.
    """
    if not pkl_path.exists():
        return None

    try:
        with open(pkl_path, 'rb') as f:
            dem_data = pickle.load(f)

        print(f"[INFO] Loaded DEM data from pkl: {pkl_path}")
        print(f"[INFO] DEM grid shape: {dem_data['dem_grid'].shape}")
        print(f"[INFO] DEM elevation difference range: {dem_data['dem_grid'].min():.2f}m to {dem_data['dem_grid'].max():.2f}m")

        return dem_data
    except Exception as e:
        print(f"[WARN] Failed to load DEM pkl: {e}")
        return None


def convert_pkl_dem_to_points(dem_data):
    """
    Convert pkl DEM grid data to point cloud format for compatibility with existing functions.
    Returns: (points_xy, elevations) where points_xy is Nx2 array in absolute UTM coordinates and elevations is N array.
    """
    dem_grid = dem_data['dem_grid']  # (ny, nx) elevation difference array
    x_grid = dem_data['x_grid']      # 1D x coordinates (relative, 0 to x_max)
    y_grid = dem_data['y_grid']      # 1D y coordinates (relative, 0 to y_max)
    x_min = dem_data['x_min']        # Absolute UTM x minimum
    y_min = dem_data['y_min']        # Absolute UTM y minimum

    # Create meshgrid in relative coordinates
    X, Y = np.meshgrid(x_grid, y_grid, indexing='xy')

    # Convert to absolute UTM coordinates
    X_abs = X + x_min
    Y_abs = Y + y_min

    # Flatten to point cloud
    points_xy = np.column_stack([X_abs.ravel(), Y_abs.ravel()])
    elevations = dem_grid.ravel()

    # Robustness: some legacy pkls may store absolute elevations instead of diffs.
    # Normalize to datum (min=0) to match load_dem_data() behavior.
    try:
        elev_min = float(np.nanmin(elevations))
    except Exception:
        elev_min = None
    if elev_min is not None and math.isfinite(elev_min) and abs(elev_min) > 1e-6:
        elevations = elevations - elev_min
        print(f"[INFO] Adjusted PKL DEM to datum (lowest point = 0). Datum offset applied: {elev_min:.2f}m")

    print(f"[INFO] Converted DEM grid to {len(elevations)} points in absolute UTM coordinates")

    return points_xy, elevations


def load_dem_data(dem_shp_path: Path, work_crs):
    """
    Load DEM elevation data from shapefile and prepare for interpolation.
    Returns: (points_xy, elevations) where points_xy is Nx2 array and elevations is N array
    """
    print(f"[INFO] Loading DEM data from: {dem_shp_path}")
    dem_gdf = gpd.read_file(dem_shp_path)
    
    if dem_gdf.empty:
        print("[WARN] DEM shapefile is empty, will use flat terrain")
        return None, None
    
    # Force geometries to 2D before reprojection to avoid Z-coordinate issues
    print("[INFO] Ensuring DEM geometries are 2D...")
    from shapely.ops import transform
    def force_2d(geom):
        """Force geometry to 2D by dropping Z coordinates"""
        if geom is None:
            return None
        return transform(lambda x, y, z=None: (x, y), geom)

    dem_gdf['geometry'] = dem_gdf['geometry'].apply(force_2d)

    # Reproject to working CRS if needed
    if dem_gdf.crs != work_crs:
        print(f"[INFO] Reprojecting DEM from {dem_gdf.crs} to {work_crs}")
        dem_gdf = dem_gdf.to_crs(work_crs)
    
    # Extract elevation values and centroids
    elevation_col = None
    for col in ['elevation', 'Elevation', 'ELEVATION', 'height', 'Height', 'z', 'Z']:
        if col in dem_gdf.columns:
            elevation_col = col
            break
    
    if elevation_col is None:
        print("[WARN] No elevation column found in DEM, will use flat terrain")
        return None, None
    
    print(f"[INFO] Using elevation column: {elevation_col}")
    
    # Get centroids and elevations
    points = []
    elevations = []
    for idx, row in dem_gdf.iterrows():
        geom = row.geometry
        if geom is None or geom.is_empty:
            continue
        elev = _safe_float(row[elevation_col])
        if elev is None:
            continue
        
        # Use centroid as representative point
        centroid = geom.centroid
        points.append([centroid.x, centroid.y])
        elevations.append(elev)
    
    if not points:
        print("[WARN] No valid DEM points found, will use flat terrain")
        return None, None
    
    points_xy = np.array(points)
    elevations = np.array(elevations)

    print(f"[INFO] Loaded {len(elevations)} DEM points")
    print(f"[INFO] Original elevation range (sea level): {elevations.min():.2f} to {elevations.max():.2f} meters")

    # Shift all elevations so minimum becomes 0 (datum adjustment)
    # This converts from sea level to relative elevation
    min_elev = elevations.min()
    elevations = elevations - min_elev

    print(f"[INFO] Adjusted to datum (lowest point = 0): {elevations.min():.2f} to {elevations.max():.2f} meters")
    print(f"[INFO] Datum offset applied: {min_elev:.2f}m")

    return points_xy, elevations


def create_elevation_lookup_grid(base_poly, dem_points, dem_elevations, grid_resolution=10.0, elevation_scale=1.0, smooth_sigma=1.0, idw_power=2.0, idw_neighbors=12):
    """
    Create a fast lookup grid for elevation queries.
    This is much faster than calling griddata() for each building.

    NOTE: dem_elevations should already be adjusted to datum (min=0)

    Args:
        base_poly: Base polygon boundary
        dem_points: Nx2 array of DEM point coordinates
        dem_elevations: N array of elevation values (already adjusted to datum)
        grid_resolution: Grid spacing in meters (smaller = more accurate but slower)
        elevation_scale: Scale factor for elevation differences
        smooth_sigma: Gaussian smoothing strength
        idw_power: IDW power parameter
        idw_neighbors: Number of nearest neighbors for IDW

    Returns:
        (X, Y, Z) grid arrays for fast bilinear interpolation
    """
    if dem_points is None or dem_elevations is None:
        return None, None, None

    print(f"[INFO] Creating elevation lookup grid (resolution: {grid_resolution}m)...")

    # Get bounds
    minx, miny, maxx, maxy = base_poly.bounds

    # Create grid
    nx = int((maxx - minx) / grid_resolution) + 1
    ny = int((maxy - miny) / grid_resolution) + 1

    x = np.linspace(minx, maxx, nx)
    y = np.linspace(miny, maxy, ny)
    X, Y = np.meshgrid(x, y)

    # Interpolate elevations on grid using IDW (do this once!)
    points_grid = np.column_stack([X.ravel(), Y.ravel()])

    from scipy.spatial import cKDTree

    # Build KD-tree for fast nearest neighbor search
    tree = cKDTree(dem_points)

    # IDW parameters
    power = idw_power
    n_neighbors = idw_neighbors

    # Query nearest neighbors
    distances, indices = tree.query(points_grid, k=n_neighbors)
    distances = np.maximum(distances, 1e-10)

    # Calculate IDW weights
    weights = 1.0 / (distances ** power)
    weights_sum = weights.sum(axis=1, keepdims=True)
    weights_normalized = weights / weights_sum

    # Interpolate elevations
    Z = np.sum(weights_normalized * dem_elevations[indices], axis=1)

    Z = Z.reshape(ny, nx)

    # Apply Gaussian smoothing (lighter than terrain mesh)
    if smooth_sigma > 0:
        from scipy.ndimage import gaussian_filter
        Z = gaussian_filter(Z, sigma=smooth_sigma * 0.5)  # Half the terrain smoothing

    # Ensure minimum is at least 0 (in case smoothing created negative values)
    if Z.min() < 0:
        Z = np.maximum(Z, 0.0)

    # Normalize to local datum (minimum within the CFD domain grid = 0).
    # This matches core/bridge_core/1_buildBC.py behavior and avoids a constant offset
    # when DEM points include an expanded area outside the CFD bounds or when smoothing
    # lifts the minimum above 0.
    z_min_grid = float(Z.min())
    if abs(z_min_grid) > 1e-9:
        Z = Z - z_min_grid
        # Numerical safety
        if Z.min() < 0:
            Z = np.maximum(Z, 0.0)

    # Apply elevation scale
    if elevation_scale != 1.0:
        Z = Z * elevation_scale

    print(f"[INFO] Elevation lookup grid created: {nx} x {ny} = {nx*ny} points")
    print(f"[INFO] Lookup grid elevation range: {Z.min():.2f} to {Z.max():.2f} meters")

    return X, Y, Z


def interpolate_elevation_fast(x, y, X_grid, Y_grid, Z_grid):
    """
    Fast elevation lookup using pre-computed grid and bilinear interpolation.

    Args:
        x, y: Query coordinates
        X_grid, Y_grid, Z_grid: Pre-computed elevation grid

    Returns:
        Interpolated elevation value
    """
    if X_grid is None or Y_grid is None or Z_grid is None:
        return 0.0

    try:
        # Get grid parameters
        ny, nx = Z_grid.shape
        x_min, x_max = X_grid[0, 0], X_grid[0, -1]
        y_min, y_max = Y_grid[0, 0], Y_grid[-1, 0]

        # Check bounds
        if x < x_min or x > x_max or y < y_min or y > y_max:
            return 0.0

        # Find grid cell
        dx = (x_max - x_min) / (nx - 1)
        dy = (y_max - y_min) / (ny - 1)

        i = int((x - x_min) / dx)
        j = int((y - y_min) / dy)

        # Clamp to valid range
        i = max(0, min(i, nx - 2))
        j = max(0, min(j, ny - 2))

        # Bilinear interpolation
        x0, x1 = X_grid[j, i], X_grid[j, i+1]
        y0, y1 = Y_grid[j, i], Y_grid[j+1, i]

        z00 = Z_grid[j, i]
        z10 = Z_grid[j, i+1]
        z01 = Z_grid[j+1, i]
        z11 = Z_grid[j+1, i+1]

        # Interpolation weights
        wx = (x - x0) / (x1 - x0) if x1 != x0 else 0.0
        wy = (y - y0) / (y1 - y0) if y1 != y0 else 0.0

        # Bilinear interpolation
        z = (1 - wx) * (1 - wy) * z00 + \
            wx * (1 - wy) * z10 + \
            (1 - wx) * wy * z01 + \
            wx * wy * z11

        return float(z)
    except Exception:
        return 0.0


def create_terrain_mesh(base_poly: Polygon, dem_points, dem_elevations, grid_resolution=50, elevation_scale=1.0, smooth_sigma=1.0, idw_power=2.0, idw_neighbors=12, base_height=50.0, proj_temp: Path = Path("./proj_temp")) -> trimesh.Trimesh:
    """
    Create a terrain mesh from DEM data within the base polygon.
    The terrain sits on top of the base layer (at z=base_height).

    NOTE: dem_elevations should already be adjusted so minimum = 0 (datum adjustment done in load_dem_data)

    Args:
        base_poly: Base polygon boundary
        dem_points: Nx2 array of DEM point coordinates
        dem_elevations: N array of elevation values (already adjusted to datum)
        grid_resolution: Grid spacing in meters
        elevation_scale: Scale factor for elevation differences (for visualization)
        smooth_sigma: Gaussian smoothing strength (0=no smoothing)
        idw_power: IDW power parameter
        idw_neighbors: Number of nearest neighbors for IDW
        base_height: Height of base layer (terrain starts from this height)

    Returns:
        terrain_mesh: trimesh object representing the terrain surface
    """
    if dem_points is None or dem_elevations is None:
        print("[INFO] No DEM data, creating flat base")
        return None

    print(f"[INFO] Creating terrain mesh with resolution {grid_resolution}m")

    # Get bounds of base polygon
    minx, miny, maxx, maxy = base_poly.bounds

    # Create grid
    nx = int((maxx - minx) / grid_resolution) + 1
    ny = int((maxy - miny) / grid_resolution) + 1

    print(f"[INFO] Grid size: {nx} x {ny} = {nx*ny} points")

    x = np.linspace(minx, maxx, nx)
    y = np.linspace(miny, maxy, ny)
    X, Y = np.meshgrid(x, y)

    # Interpolate elevations on grid
    points_grid = np.column_stack([X.ravel(), Y.ravel()])

    # Use Inverse Distance Weighting (IDW) interpolation
    # IDW is more stable and doesn't extrapolate beyond data range
    print("[INFO] Interpolating elevations using Inverse Distance Weighting (IDW)...")

    from scipy.spatial import cKDTree

    # Build KD-tree for fast nearest neighbor search
    tree = cKDTree(dem_points)

    # IDW parameters
    power = idw_power  # Power parameter (higher = more weight to closer points)
    n_neighbors = idw_neighbors  # Number of nearest neighbors to use

    # Query nearest neighbors for all grid points
    distances, indices = tree.query(points_grid, k=n_neighbors)

    # Avoid division by zero for points exactly on DEM points
    distances = np.maximum(distances, 1e-10)

    # Calculate IDW weights
    weights = 1.0 / (distances ** power)
    weights_sum = weights.sum(axis=1, keepdims=True)
    weights_normalized = weights / weights_sum

    # Interpolate elevations
    Z = np.sum(weights_normalized * dem_elevations[indices], axis=1)

    print(f"[INFO] IDW interpolation complete using {n_neighbors} nearest neighbors")

    Z = Z.reshape(ny, nx)

    # Apply Gaussian smoothing for even smoother terrain
    if smooth_sigma > 0:
        print(f"[INFO] Applying Gaussian smoothing (sigma={smooth_sigma:.1f}) for terrain smoothness...")
        from scipy.ndimage import gaussian_filter
        Z = gaussian_filter(Z, sigma=smooth_sigma)
    else:
        print("[INFO] Smoothing disabled (sigma=0)")

    print(f"[INFO] Interpolated elevation range: {Z.min():.2f} to {Z.max():.2f} meters")

    # Ensure minimum is at least 0 (in case smoothing created negative values)
    if Z.min() < 0:
        print(f"[WARN] Smoothing created negative values (min={Z.min():.2f}m), clipping to 0")
        Z = np.maximum(Z, 0.0)

    # Normalize to local datum (minimum within the CFD domain grid = 0).
    # This matches core/bridge_core/1_buildBC.py behavior and avoids a constant offset
    # when DEM points include an expanded bbox outside the CFD bounds or when smoothing
    # lifts the minimum above 0.
    z_min_grid = float(Z.min())
    if abs(z_min_grid) > 1e-9:
        print(f"[INFO] Normalizing terrain to local datum (grid min -> 0). Offset removed: {z_min_grid:.3f}m")
        Z = Z - z_min_grid
        if Z.min() < 0:
            Z = np.maximum(Z, 0.0)

    # Apply elevation scale (for visualization/testing)
    if elevation_scale != 1.0:
        print(f"[INFO] Applying elevation scale factor: {elevation_scale}x")
        Z = Z * elevation_scale

    print(f"[INFO] Final terrain elevation range: {Z.min():.2f} to {Z.max():.2f} meters")

    # Export interpolated DEM to CSV
    csv_path = proj_temp / "interpolated_dem.csv"
    print(f"[INFO] Exporting interpolated DEM to {csv_path}")
    with open(csv_path, 'w') as f:
        f.write("x,y,elevation\n")
        for i in range(ny):
            for j in range(nx):
                f.write(f"{X[i, j]:.3f},{Y[i, j]:.3f},{Z[i, j]:.3f}\n")
    print(f"[INFO] Exported {nx * ny} interpolated elevation points to {csv_path}")

    # Verify the minimum is now ~0
    actual_min = Z.min()
    if abs(actual_min) > 0.01:
        print(f"[WARN] Minimum elevation is {actual_min:.2f}m, expected ~0.00m")

    # Create a solid terrain mesh (from base_height to terrain surface)
    # This sits on top of the base layer

    # Create top surface vertices (terrain surface on top of base layer)
    vertices_top = []
    for i in range(ny):
        for j in range(nx):
            vertices_top.append([X[i, j], Y[i, j], base_height + Z[i, j]])

    # Create bottom surface vertices (at base_height, top of base layer)
    vertices_bottom = []
    for i in range(ny):
        for j in range(nx):
            vertices_bottom.append([X[i, j], Y[i, j], base_height])

    vertices = np.vstack([vertices_top, vertices_bottom])

    # Create faces
    faces = []
    n_top = ny * nx

    # Top surface triangles
    for i in range(ny - 1):
        for j in range(nx - 1):
            v0 = i * nx + j
            v1 = i * nx + (j + 1)
            v2 = (i + 1) * nx + j
            v3 = (i + 1) * nx + (j + 1)

            faces.append([v0, v1, v2])
            faces.append([v1, v3, v2])

    # Bottom surface triangles (reversed winding)
    for i in range(ny - 1):
        for j in range(nx - 1):
            v0 = n_top + i * nx + j
            v1 = n_top + i * nx + (j + 1)
            v2 = n_top + (i + 1) * nx + j
            v3 = n_top + (i + 1) * nx + (j + 1)

            faces.append([v0, v2, v1])
            faces.append([v1, v2, v3])

    # Side faces (connect top and bottom edges)
    # Left edge (j=0)
    for i in range(ny - 1):
        v0_top = i * nx
        v1_top = (i + 1) * nx
        v0_bot = n_top + i * nx
        v1_bot = n_top + (i + 1) * nx
        faces.append([v0_top, v1_top, v0_bot])
        faces.append([v1_top, v1_bot, v0_bot])

    # Right edge (j=nx-1)
    for i in range(ny - 1):
        v0_top = i * nx + (nx - 1)
        v1_top = (i + 1) * nx + (nx - 1)
        v0_bot = n_top + i * nx + (nx - 1)
        v1_bot = n_top + (i + 1) * nx + (nx - 1)
        faces.append([v0_top, v0_bot, v1_top])
        faces.append([v1_top, v0_bot, v1_bot])

    # Front edge (i=0)
    for j in range(nx - 1):
        v0_top = j
        v1_top = j + 1
        v0_bot = n_top + j
        v1_bot = n_top + j + 1
        faces.append([v0_top, v0_bot, v1_top])
        faces.append([v1_top, v0_bot, v1_bot])

    # Back edge (i=ny-1)
    for j in range(nx - 1):
        v0_top = (ny - 1) * nx + j
        v1_top = (ny - 1) * nx + j + 1
        v0_bot = n_top + (ny - 1) * nx + j
        v1_bot = n_top + (ny - 1) * nx + j + 1
        faces.append([v0_top, v1_top, v0_bot])
        faces.append([v1_top, v1_bot, v0_bot])

    faces = np.array(faces)

    terrain_mesh = trimesh.Trimesh(vertices=vertices, faces=faces)

    print(f"[INFO] Terrain mesh created: {len(vertices)} vertices, {len(faces)} faces")
    print(f"[INFO] Terrain is a solid volume from z={base_height}m to terrain surface")

    return terrain_mesh

def extrude_polygon_to_mesh(poly: Polygon, height: float) -> trimesh.Trimesh:
    def _ensure_2d_coords(coords):
        """Ensure coordinates are 2D"""
        return [(x, y) for x, y, *_ in coords] if len(coords[0]) > 2 else coords

    exterior_coords = list(poly.exterior.coords)
    exterior_2d = _ensure_2d_coords(exterior_coords)

    holes_2d = []
    for interior in poly.interiors:
        interior_coords = list(interior.coords)
        interior_2d = _ensure_2d_coords(interior_coords)
        holes_2d.append(interior_2d)

    if holes_2d:
        poly_2d = Polygon(exterior_2d, holes_2d)
    else:
        poly_2d = Polygon(exterior_2d)

    try:
        mesh = trimesh.creation.extrude_polygon(poly_2d, height, engine="earcut")
    except Exception:
        try:
            mesh = trimesh.creation.extrude_polygon(poly_2d, height, engine="triangle")
        except Exception as e:
            raise RuntimeError("No triangulation engine available, please install mapbox_earcut or triangle") from e

    return mesh

def _build_bbox_polygon_from_conf(conf_path) -> Polygon:
    """
    Parse conf file to extract cut_lon_manual and cut_lat_manual to create bounding box polygon.
    """
    conf_file = Path(conf_path).expanduser().resolve()
    if not conf_file.exists():
        raise FileNotFoundError(f"[ERROR] Configuration file not found: {conf_file}")
    txt = conf_file.read_text(encoding="utf-8", errors="ignore")

    m_lon = re.search(r"cut_lon_manual\s*=\s*\[([^\]]+)\]", txt)
    m_lat = re.search(r"cut_lat_manual\s*=\s*\[([^\]]+)\]", txt)
    if not (m_lon and m_lat):
        raise ValueError("conf 中未找到 cut_lon_manual/cut_lat_manual")

    lon_vals = [float(v.strip()) for v in m_lon.group(1).split(",")]
    lat_vals = [float(v.strip()) for v in m_lat.group(1).split(",")]
    minx, maxx = min(lon_vals), max(lon_vals)
    miny, maxy = min(lat_vals), max(lat_vals)

    ring = [(minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny)]
    return Polygon(ring)


def _project_geometry(geom: Polygon, target_crs) -> Polygon:
    """
    Project geometry to target CRS using GeoSeries's to_crs.
    """
    gs = gpd.GeoSeries([geom], crs="EPSG:4326")
    gs2 = gs.to_crs(target_crs)
    result = gs2.iloc[0]
    if isinstance(result, Polygon):
        return result
    else:
        raise RuntimeError(f"投影结果不是Polygon类型: {type(result)}")

def _init_worker(elev_data):
    """
    Initialize global elevation data in worker process.
    """
    global X_ELEV_GRID, Y_ELEV_GRID, Z_ELEV_GRID, BASE_HEIGHT_FOR_BUILDING
    X_ELEV_GRID, Y_ELEV_GRID, Z_ELEV_GRID, BASE_HEIGHT_FOR_BUILDING = elev_data


def _build_one_proc(task):
    """
    Build one building mesh in worker process.
    """
    idx, poly, h = task
    if h <= 0:
        return idx, None, None, None
    try:
        terrain_elevs = []
        for coord in poly.exterior.coords:
            x, y = coord[0], coord[1]
            elev = interpolate_elevation_fast(
                x, y,
                X_ELEV_GRID, Y_ELEV_GRID, Z_ELEV_GRID
            )
            terrain_elevs.append(elev)
        min_terrain_elev = min(terrain_elevs) if terrain_elevs else 0.0
        base_elev = BASE_HEIGHT_FOR_BUILDING + min_terrain_elev
        m = extrude_polygon_to_mesh(poly, h)
        m.apply_translation([0.0, 0.0, base_elev])
        return idx, m, base_elev, None
    except Exception as e:
        return idx, None, None, e
    
def _poly_from_raw(raw):
    exterior, holes = raw
    if holes:
        return Polygon(exterior, holes)
    else:
        return Polygon(exterior)

def _build_batch_from_raw(batch):
    results = []
    for idx, raw_poly, h in batch:
        poly = _poly_from_raw(raw_poly)
        results.append(_build_one_proc((idx, poly, h)))
    return results

def _build_batch_proc(tasks_batch):
    results = []
    for t in tasks_batch:
        results.append(_build_one_proc(t))
    return results

def main():
    program_start_time = time.time()
    parser = argparse.ArgumentParser(
        description="Voxelization of buildings with terrain-aware base elevation"
    )
    parser.add_argument(
        "conf",
        help="path to deck file"
    )
    parser.add_argument(
        "--height-field",
        default="auto",
        help="height field in shapefile, or 'auto' to detect (Height, Elevation, etc.). Default 'auto'"
    )
    parser.add_argument(
        "--min-height",
        type=float,
        default=0.0,
        help="minimum valid height in meters. Buildings with height less than this will be ignored. Default 0.0"
    )
    parser.add_argument(
        "--no-reproject",
        action="store_true",
        help="do not reproject shapefile to UTM, use original CRS"
    )
    parser.add_argument(
        "--dem-path",
        type=str,
        default=None,
        help="path to DEM shapefile. If not provided, will look for DEM folder in project home"
    )
    parser.add_argument(
        "--dem-source",
        type=str,
        choices=("auto", "shp", "pkl"),
        default="auto",
        help="DEM source selection. auto=prefer shapefile/GeoTIFF then fallback to PKL. Default: auto"
    )
    parser.add_argument(
        "--terrain-resolution",
        type=float,
        default=50.0,
        help="terrain mesh grid resolution in meters. Default 50.0"
    )
    parser.add_argument(
        "--max-buildings",
        type=int,
        default=None,
        help="maximum number of buildings to process (for testing). Default: process all buildings"
    )
    parser.add_argument(
        "--elevation-scale",
        type=float,
        default=1.0,
        help="scale factor for elevation differences (for visualization/testing). Default: 1.0"
    )
    parser.add_argument(
        "--smooth-sigma",
        type=float,
        default=1.0,
        help="Gaussian smoothing strength for terrain (0=no smoothing, 1=default, 2=very smooth). Default: 1.0"
    )
    parser.add_argument(
        "--idw-power",
        type=float,
        default=2.0,
        help="IDW power parameter (higher = more weight to closer points, 1-3 recommended). Default: 2.0"
    )
    parser.add_argument(
        "--idw-neighbors",
        type=int,
        default=12,
        help="Number of nearest neighbors for IDW interpolation. Default: 12"
    )
    parser.add_argument(
        "--base-height",
        type=float,
        default=None,
        help="Base layer height in meters (terrain sits on top of this). If not set, will read base_height from conf (fallback 50.0)."
    )

    args = parser.parse_args()
    print("[INFO] Parsed CLI arguments")

    conf_file = Path(args.conf).expanduser().resolve()
    if not conf_file.exists():
        raise FileNotFoundError(f"conf file not found: {conf_file}")
    project_home = conf_file.parent
    proj_temp = project_home / "proj_temp"
    proj_temp.mkdir(parents=True, exist_ok=True)

    txt_conf = conf_file.read_text(encoding="utf-8", errors="ignore")
    m_case = re.search(r"casename\s*=\s*([^\s]+)", txt_conf)
    if not m_case:
        raise RuntimeError("casename not found in conf")
    case_name = m_case.group(1)

    # If --base-height is not provided, read from conf (same behavior as 1_buildBC.py)
    if args.base_height is None:
        conf_base_height = _parse_base_height_from_conf_raw(txt_conf)
        args.base_height = conf_base_height if conf_base_height is not None else 50.0
    if (not math.isfinite(float(args.base_height))) or (float(args.base_height) < 0.0):
        args.base_height = 50.0
    print(f"[INFO] Base height: {args.base_height} m")

    try:
        utm_crs = get_utm_crs_from_conf_raw(txt_conf, default_epsg=None)
    except Exception as e:
        raise RuntimeError(f"[ERROR] Failed to determine UTM CRS from conf (cut_lon_manual/cut_lat_manual): {e}")
    print(f"[INFO] UTM CRS for CFD domain: {utm_crs}")


    # Find building shapefile
    primary_shp = proj_temp / f"cutted_shp/{case_name}.shp"
    fallback_shp = proj_temp / f"{case_name}.shp"

    if primary_shp.exists():
        shp_path = primary_shp
    elif fallback_shp.exists():
        print(f"[WARN] Primary shapefile not found: {primary_shp.name}. Fallback to {fallback_shp.name}")
        shp_path = fallback_shp
    else:
        raise FileNotFoundError(f"Shapefile not found: {primary_shp} or {fallback_shp}")

    print(f"[INFO] Input Shapefile: {shp_path}")
    print(f"[INFO] Height field: {args.height_field}")
    print(f"[INFO] Min valid height: {args.min_height} m")

    combined_file = proj_temp / f"{case_name}.stl"

    print(f"[INFO] Reading features from file")
    gdf = gpd.read_file(shp_path)
    if len(gdf) == 0:
        raise RuntimeError("Shapefile has no features")
    print(f"[INFO] Read {len(gdf)} features")
    print(f"[INFO] Source CRS: {gdf.crs}")

    if gdf.crs is None:
        gdf = gdf.set_crs("EPSG:4326", allow_override=True)

    # Use UTM CRS determined from configuration
    gdf_work = gdf.copy()
    if not args.no_reproject:
        try:
            gdf_work = gdf_work.to_crs(utm_crs)
        except Exception as e:
            raise RuntimeError(f"[ERROR] Failed to reproject buildings to {utm_crs}: {e}")

    work_crs = gdf_work.crs
    print(f"[INFO] Working CRS for CFD domain: {work_crs}")


    # DEM loading strategy (prefer SHP/GeoTIFF by default; PKL is typically coarser and may cause blocky terrain)
    proj_temp = project_home / "proj_temp"
    dem_pkl_path = proj_temp / "dem_grid.pkl"

    dem_points, dem_elevations = None, None
    dem_data_pkl = None
    use_pkl_dem = False

    def _try_load_dem_shp() -> tuple[np.ndarray | None, np.ndarray | None]:
        if args.dem_path:
            dem_path = Path(args.dem_path)
            print(f"[INFO] Using user-provided DEM shapefile: {dem_path}")
        else:
            dem_path = None
            for folder_name in ("terrain_db", "DEM"):
                dem_folder = project_home / folder_name
                if dem_folder.exists():
                    dem_files = sorted(dem_folder.glob("*.shp"))
                    if dem_files:
                        dem_path = dem_files[0]
                        print(f"[INFO] Auto-detected DEM file: {dem_path}")
                        break
                    else:
                        print(f"[WARN] No DEM shapefile found in {folder_name} folder")
        if dem_path and dem_path.exists():
            return load_dem_data(dem_path, work_crs)
        print("[INFO] No DEM shapefile found. Trying GeoTIFF fallback...")
        created = ensure_dem_shp_from_tif(txt_conf, project_home)
        if created and created.exists():
            return load_dem_data(created, work_crs)
        return None, None

    def _try_load_dem_pkl() -> tuple[np.ndarray | None, np.ndarray | None, dict | None]:
        pkl_data = load_dem_from_pkl(dem_pkl_path)
        if pkl_data is None:
            return None, None, None
        pts, elevs = convert_pkl_dem_to_points(pkl_data)
        return pts, elevs, pkl_data

    if args.dem_source in ("auto", "shp"):
        print("[INFO] Loading DEM from shapefile/GeoTIFF ...")
        dem_points, dem_elevations = _try_load_dem_shp()

    if dem_points is None and args.dem_source in ("auto", "pkl", "shp"):
        if args.dem_source == "shp":
            print("[WARN] DEM shapefile/GeoTIFF not available. Falling back to PKL if present.")
        print("[INFO] Loading DEM from PKL ...")
        dem_points, dem_elevations, dem_data_pkl = _try_load_dem_pkl()
        use_pkl_dem = dem_data_pkl is not None and dem_points is not None and dem_elevations is not None
        if use_pkl_dem:
            print("[INFO] Using DEM data from pkl file (dem_grid.pkl)")
            try:
                pkl_base_height = _safe_float(dem_data_pkl.get("base_height"))
            except Exception:
                pkl_base_height = None
            if pkl_base_height is not None and abs(float(pkl_base_height) - float(args.base_height)) > 1e-6:
                print(
                    f"[WARN] PKL base_height={float(pkl_base_height):.3f}m differs from current base_height={float(args.base_height):.3f}m. "
                    f"STL will use base_height={float(args.base_height):.3f}m."
                )

    if dem_points is None:
        print("[INFO] No DEM data available, will create flat terrain")

    # Auto-detect height field
    if args.height_field == "auto":
        height_candidates = ["Height", "Elevation", "height", "elevation", "HEIGHT", "ELEVATION"]
        height_field = None
        for candidate in height_candidates:
            if candidate in gdf_work.columns:
                height_field = candidate
                print(f"[INFO] Auto-detected height field: {height_field}")
                break
        if height_field is None:
            raise RuntimeError(f"Cannot auto-detect height field. Available fields: {list(gdf_work.columns)}")
        args.height_field = height_field
    else:
        print(f"[INFO] Using specified height field: {args.height_field}")

    # Build bbox - project only two corner points (same as 1_buildBC.py)
    conf_file_path = Path(conf_file).expanduser().resolve()
    if not conf_file_path.exists():
        raise FileNotFoundError(f"[ERROR] Configuration file not found: {conf_file_path}")
    txt = conf_file_path.read_text(encoding="utf-8", errors="ignore")

    m_lon = re.search(r"cut_lon_manual\s*=\s*\[([^\]]+)\]", txt)
    m_lat = re.search(r"cut_lat_manual\s*=\s*\[([^\]]+)\]", txt)
    if not (m_lon and m_lat):
        raise ValueError("conf 中未找到 cut_lon_manual/cut_lat_manual")

    lon_vals = [float(v.strip()) for v in m_lon.group(1).split(",")]
    lat_vals = [float(v.strip()) for v in m_lat.group(1).split(",")]
    lon_min, lon_max = min(lon_vals), max(lon_vals)
    lat_min, lat_max = min(lat_vals), max(lat_vals)

    print(f"[INFO] Config bounds: lon=[{lon_min}, {lon_max}], lat=[{lat_min}, {lat_max}]")

    # Project four corner points to UTM (consistent with buildBC rotation logic)
    from pyproj import Transformer
    transformer = Transformer.from_crs("EPSG:4326", work_crs, always_xy=True)
    x00, y00 = transformer.transform(lon_min, lat_min)
    x10, y10 = transformer.transform(lon_max, lat_min)
    x11, y11 = transformer.transform(lon_max, lat_max)
    x01, y01 = transformer.transform(lon_min, lat_max)

    # Read rotate_deg from conf when present; otherwise compute from lower edge
    m_rot = re.search(r"rotate_deg\s*=\s*([-+]?\d+(?:\.\d+)?(?:[eE][-+]?\d+)?)", txt)
    if m_rot:
        rotate_deg_conf = float(m_rot.group(1))
    else:
        dx0 = x10 - x00
        dy0 = y10 - y00
        angle_rad = math.atan2(dy0, dx0)
        rotate_deg_conf = -math.degrees(angle_rad)

    pivot_xy_conf = (
        (x00 + x10 + x11 + x01) / 4.0,
        (y00 + y10 + y11 + y01) / 4.0,
    )

    corners = np.array([[x00, y00], [x10, y10], [x11, y11], [x01, y01]], dtype=float)
    corners_rot = _rotate_points_xy(corners, rotate_deg_conf, pivot_xy_conf)

    x_min_conf = float(corners_rot[:, 0].min())
    x_max_conf = float(corners_rot[:, 0].max())
    y_min_conf = float(corners_rot[:, 1].min())
    y_max_conf = float(corners_rot[:, 1].max())

    print(
        f"[INFO] Projected corners (UTM): "
        f"({x00:.3f},{y00:.3f}) ({x10:.3f},{y10:.3f}) ({x11:.3f},{y11:.3f}) ({x01:.3f},{y01:.3f})"
    )
    print(f"[INFO] Rotation from conf/config: rotate_deg={rotate_deg_conf:.6f}, pivot=({pivot_xy_conf[0]:.3f}, {pivot_xy_conf[1]:.3f})")
    print(f"[INFO] Domain size in rotated frame: {x_max_conf - x_min_conf:.3f} x {y_max_conf - y_min_conf:.3f} m")

    # Build boundary box and rotation
    if use_pkl_dem and dem_data_pkl is not None:
        x_min_pkl = float(dem_data_pkl["x_min"])
        y_min_pkl = float(dem_data_pkl["y_min"])

        x_grid_pkl = np.asarray(dem_data_pkl["x_grid"])
        y_grid_pkl = np.asarray(dem_data_pkl["y_grid"])

        minx = x_min_pkl
        miny = y_min_pkl
        maxx = x_min_pkl + float(x_grid_pkl.max())
        maxy = y_min_pkl + float(y_grid_pkl.max())

        rotate_deg = float(dem_data_pkl.get("rotate_deg", 0.0))
        pivot_xy_raw = dem_data_pkl.get("pivot_xy", ((minx + maxx) / 2, (miny + maxy) / 2))
        pivot_xy = (float(pivot_xy_raw[0]), float(pivot_xy_raw[1]))

        base_rot = Polygon([(minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy)])
        print(f"[INFO] Using pkl DEM bounds: x=[{minx:.3f}, {maxx:.3f}], y=[{miny:.3f}, {maxy:.3f}]")
        print(f"[INFO] Using pkl rotation: rotate_deg={rotate_deg:.6f}, pivot=({pivot_xy[0]:.3f}, {pivot_xy[1]:.3f})")
    else:
        minx, miny, maxx, maxy = x_min_conf, y_min_conf, x_max_conf, y_max_conf
        base_rot = Polygon([(minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy)])
        rotate_deg = rotate_deg_conf
        pivot_xy = (float(pivot_xy_conf[0]), float(pivot_xy_conf[1]))
        print("[INFO] Using config-rotated bounding box (match buildBC CSV frame)")
    # Rotate DEM points into the same rotated frame when DEM is not from pkl
    if (dem_points is not None) and (not use_pkl_dem) and (rotate_deg != 0.0):
        dem_points = _rotate_points_xy(dem_points, rotate_deg, pivot_xy)

    # Filter buildings by height (no rotation needed)
    print("[INFO] Filtering building polygons by height")
    rotated_polygons = []
    heights = []
    for _, row in gdf_work.iterrows():
        geom = row.geometry
        if geom is None or geom.is_empty:
            continue
        h = _safe_float(row.get(args.height_field))
        if h is None or h <= args.min_height:
            continue
        geom_valid = _make_valid(geom)
        if geom_valid is None or geom_valid.is_empty:
            continue
        polys = _to_iter_polygons(geom_valid)
        if not polys:
            continue
        for poly in polys:
            try:
                if rotate_deg != 0.0:
                    poly_use = affinity.rotate(poly, rotate_deg, origin=pivot_xy, use_radians=False)
                else:
                    poly_use = poly
                rotated_polygons.append(poly_use)
                heights.append(h)
            except Exception:
                continue


    if not rotated_polygons:
        raise RuntimeError("[ERROR] No valid building polygons available")

    # Clip buildings to boundary
    print("[INFO] Clipping buildings to boundary box")
    clipped_polygons = []
    clipped_heights = []
    boundary_box = base_rot

    for poly, h in zip(rotated_polygons, heights):
        try:
            clipped = poly.intersection(boundary_box)
            if not clipped.is_empty and clipped.area > 0:
                if isinstance(clipped, Polygon):
                    clipped_polygons.append(clipped)
                    clipped_heights.append(h)
                elif isinstance(clipped, MultiPolygon):
                    for sub_poly in clipped.geoms:
                        if isinstance(sub_poly, Polygon) and sub_poly.area > 0:
                            clipped_polygons.append(sub_poly)
                            clipped_heights.append(h)
        except Exception:
            continue

    rotated_polygons = clipped_polygons
    heights = clipped_heights
    print(f"[INFO] Clipped buildings: {len(rotated_polygons)} polygons remaining")

    if heights:
        print(f"[INFO] Building height stats: min {min(heights):.3f}m, max {max(heights):.3f}m")

    # Limit number of buildings if specified (for testing)
    if args.max_buildings is not None and len(rotated_polygons) > args.max_buildings:
        print(f"[INFO] Limiting to first {args.max_buildings} buildings (--max-buildings parameter)")
        rotated_polygons = rotated_polygons[:args.max_buildings]
        heights = heights[:args.max_buildings]

    # Calculate translation to origin
    minx_all, miny_all = base_rot.bounds[0], base_rot.bounds[1]
    tx, ty = -minx_all, -miny_all

    base_final = affinity.translate(base_rot, xoff=tx, yoff=ty)
    print(f"[INFO] Translation offsets: dx {tx:.3f}, dy {ty:.3f}")

    shifted_polygons = [affinity.translate(p, xoff=tx, yoff=ty) for p in rotated_polygons]

    # Translate DEM points
    if dem_points is not None:
        dem_points[:, 0] += tx
        dem_points[:, 1] += ty

    # Create base layer (z=0 to z=base_height)
    print(f"[INFO] Creating base layer from z=0 to z={args.base_height}m")
    base_mesh = extrude_polygon_to_mesh(base_final, args.base_height)
    print("[INFO] Base layer created")

    # Create terrain mesh (sits on top of base layer)
    terrain_mesh = create_terrain_mesh(
        base_final,
        dem_points,
        dem_elevations,
        args.terrain_resolution,
        elevation_scale=args.elevation_scale,
        smooth_sigma=args.smooth_sigma,
        idw_power=args.idw_power,
        idw_neighbors=args.idw_neighbors,
        base_height=args.base_height,
        proj_temp=proj_temp
    )
    
    dem_used = terrain_mesh is not None
    if dem_used:
        combined_file = proj_temp / f"{case_name}_DEM.stl"
    else:
        combined_file = proj_temp / f"{case_name}.stl"
    print(f"[INFO] Combined STL output path: {combined_file}")
    # Create fast elevation lookup grid for building placement
    # Use finer resolution (10m) for more accurate building base elevations
    # Note: dem_elevations are already adjusted to datum (min=0)
    X_elev_grid, Y_elev_grid, Z_elev_grid = create_elevation_lookup_grid(
        base_final,
        dem_points,
        dem_elevations,
        grid_resolution=10.0,
        elevation_scale=args.elevation_scale,
        smooth_sigma=args.smooth_sigma,
        idw_power=args.idw_power,
        idw_neighbors=args.idw_neighbors
    )

    # Report terrain statistics
    if terrain_mesh is not None:
        min_terrain_z = terrain_mesh.vertices[:, 2].min()
        max_terrain_z = terrain_mesh.vertices[:, 2].max()
        print(f"[INFO] Terrain layer elevation range: {min_terrain_z:.2f}m to {max_terrain_z:.2f}m")
        print(f"[INFO] Terrain relief: {max_terrain_z - min_terrain_z:.2f}m")

    # Generate building meshes
    building_meshes = []
    failed_count = 0
    building_base_elevations = []

    total_buildings = len(shifted_polygons)
    extrude_start_time = time.time()
    print(f"[INFO] Extruding {total_buildings} buildings in parallel...")


    raw_polys = []
    for poly in shifted_polygons:
        ext = [(x, y) for x, y, *rest in poly.exterior.coords]
        holes = []
        for ring in poly.interiors:
            holes.append([(x, y) for x, y, *rest in ring.coords])
        raw_polys.append((ext, holes))

    import random

    tasks = [(i, raw_polys[i], heights[i]) for i in range(len(raw_polys))]
    random.shuffle(tasks)

    max_workers = min(64, os.cpu_count() or 1)
    print(f"[INFO] Using up to {max_workers} parallel workers")
    batch_size = 500

    task_batches = [tasks[i:i + batch_size] for i in range(0, len(tasks), batch_size)]

    sys.stdout.write(f"[INFO] Using {len(task_batches)} batches for {batch_size} parallel tasks |")
    sys.stdout.flush()


    max_workers = min(32, os.cpu_count() or 1)

    results = [None] * len(tasks)

    nz = len(tasks)
    next_percent_idx = 1
    completed = 0

    elev_data = (X_elev_grid, Y_elev_grid, Z_elev_grid, args.base_height)

    with concurrent.futures.ProcessPoolExecutor(
        max_workers=max_workers,
        initializer=_init_worker,
        initargs=(elev_data,)
    ) as executor:
        future_to_batch = {}
        for batch in task_batches:
            fut = executor.submit(_build_batch_from_raw, batch)
            future_to_batch[fut] = batch

            done_now = [f for f in list(future_to_batch) if f.done()]
            for future in done_now:
                batch_res = future.result()
                for res in batch_res:
                    idx, m, base_elev, err = res
                    results[idx] = res

                    completed += 1
                    progress_ratio = completed / nz if nz > 0 else 1.0
                    while next_percent_idx <= 20 and progress_ratio >= (next_percent_idx / 20.0):
                        sys.stdout.write("#")
                        if next_percent_idx % 4 == 0:
                            sys.stdout.write(f"|{next_percent_idx * 5}%|")
                        sys.stdout.flush()
                        next_percent_idx += 1
                del future_to_batch[future]

        for future in concurrent.futures.as_completed(list(future_to_batch)):
            batch_res = future.result()
            for res in batch_res:
                idx, m, base_elev, err = res
                results[idx] = res

                completed += 1
                progress_ratio = completed / nz if nz > 0 else 1.0
                while next_percent_idx <= 20 and progress_ratio >= (next_percent_idx / 20.0):
                    sys.stdout.write("#")
                    if next_percent_idx % 4 == 0:
                        sys.stdout.write(f"|{next_percent_idx * 5}%|")
                    sys.stdout.flush()
                    next_percent_idx += 1

        sys.stdout.flush()

    sys.stdout.write("|Finished|\n")
    sys.stdout.flush()

    for idx, m, base_elev, err in results:
        if err is not None:
            failed_count += 1
            if failed_count <= 5:
                print(f"[WARN] Building {idx} extrusion failed: {err}")
            continue
        building_meshes.append(m)
        building_base_elevations.append(base_elev)

    extrude_elapsed = time.time() - extrude_start_time
    print(f"[INFO] Extruding all buildings took {extrude_elapsed:.2f} seconds")

    if failed_count > 0:
        print(f"[WARN] Total {failed_count} buildings failed to extrude")

    print(f"[INFO] Extruded {len(building_meshes)} building meshes")


    if building_base_elevations:
        base_elev_array = np.array(building_base_elevations)
        print(f"[INFO] Building base elevation stats:")
        print(f"       Min: {base_elev_array.min():.2f}m, Max: {base_elev_array.max():.2f}m")
        print(f"       Mean: {base_elev_array.mean():.2f}m, Std: {base_elev_array.std():.2f}m")

    # Combine all layers: base + terrain + buildings
    meshes_to_combine = [base_mesh]
    if terrain_mesh is not None:
        meshes_to_combine.append(terrain_mesh)
    if building_meshes:
        meshes_to_combine.extend(building_meshes)

    if len(meshes_to_combine) == 1:
        print("[INFO] Only base layer, no terrain or buildings")
        final_mesh = base_mesh
    else:
        try:
            layer_names = ["base"]
            if terrain_mesh is not None:
                layer_names.append("terrain")
            if building_meshes:
                layer_names.append(f"{len(building_meshes)} buildings")
            print(f"[INFO] Combining layers: {', '.join(layer_names)}")
            final_mesh = trimesh.util.concatenate(meshes_to_combine)
            print("[INFO] Mesh combination succeeded")
        except Exception as e:
            print(f"[WARN] Mesh combination failed: {e}")
            final_mesh = trimesh.util.concatenate(meshes_to_combine)

    final_mesh.export(combined_file, file_type="stl")
    print(f"[INFO] Exported STL with terrain: {combined_file.resolve()}")

    # Report statistics
    minx, miny, maxx, maxy = base_final.bounds
    corners = [
        (minx, miny),
        (maxx, miny),
        (maxx, maxy),
        (minx, maxy)
    ]
    print("[RESULT] Base rectangle corners in meters")
    print(f"[RESULT] Lower left: ({corners[0][0]:.3f}, {corners[0][1]:.3f})")
    print(f"[RESULT] Lower right: ({corners[1][0]:.3f}, {corners[1][1]:.3f})")
    print(f"[RESULT] Upper right: ({corners[2][0]:.3f}, {corners[2][1]:.3f})")
    print(f"[RESULT] Upper left: ({corners[3][0]:.3f}, {corners[3][1]:.3f})")

    min_bounds, max_bounds = final_mesh.bounds
    zmin = float(min_bounds[2])
    zmax = float(max_bounds[2])
    print(f"[RESULT] STL Z range: min {zmin:.3f}m, max {zmax:.3f}m")
    print(f"[RESULT] Total height: {(zmax - zmin):.3f}m")
    program_elapsed = time.time() - program_start_time
    print(f"[INFO] Program total time: {program_elapsed:.2f} seconds")

if __name__ == "__main__":
    main()


