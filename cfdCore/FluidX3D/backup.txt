#include "setup.hpp"
#include <fstream>
#include <sstream>
#include <vector>
#include <limits>
#include <atomic>
#include <cstdlib>
#include <cfloat>  // lwg
#include <chrono>   
#include <ctime>    // std::localtime
#include <iomanip>  // std::put_time
#include <thread>
#include <cstdio>
#include <algorithm>
#include <functional>
#include <cmath>
#include <cassert>


// ────────────── Global configuration ───────────────
std::string caseName = "tianfu";
std::string datetime = "20250721015000";
float        z_si_offset = 50.0f;
std::string downstream_bc = "+y";
std::string downstream_bc_yaw = "INTERNAL ERROR";
uint         memory = 20000u;
float3       si_size = float3(0);
uint Dx = 1u, Dy = 1u, Dz = 1u;
std::string conf_used_path = "Integrated defaults (conf.txt not found)";
std::string validation = "error";

struct SamplePoint { float3 p; float3 u; };

// 双进度条 单行覆盖打印 粒度为 0.1%
static std::atomic<int> g_last_light_tenths{ -1 };
static std::atomic<int> g_last_heavy_tenths{ -1 };
static std::atomic<int> g_last_line_len{ 0 };

// 将 "Light xx.x% | Heavy yy.y%" 原地刷新到同一行
static inline void print_progress_inline(double light_pct, double heavy_pct, bool force = false) {
    int lt = (int)(light_pct * 10.0 + 0.5); if (lt < 0) lt = 0; if (lt > 1000) lt = 1000;
    int ht = (int)(heavy_pct * 10.0 + 0.5); if (ht < 0) ht = 0; if (ht > 1000) ht = 1000;

    int last_lt = g_last_light_tenths.load(std::memory_order_relaxed);
    int last_ht = g_last_heavy_tenths.load(std::memory_order_relaxed);
    if (!force && lt == last_lt && ht == last_ht) return;

    g_last_light_tenths.store(lt, std::memory_order_relaxed);
    g_last_heavy_tenths.store(ht, std::memory_order_relaxed);

    int lip = lt / 10, lfp = lt % 10;
    int hip = ht / 10, hfp = ht % 10;

    std::string line = "| Light " + std::to_string(lip) + "." + std::to_string(lfp) +
        "% | Heavy " + std::to_string(hip) + "." + std::to_string(hfp) + "% |";

    int prev_len = g_last_line_len.load(std::memory_order_relaxed);
    if ((int)line.size() < prev_len) line.append(prev_len - (int)line.size(), ' ');
    g_last_line_len.store((int)line.size(), std::memory_order_relaxed);

    std::fputc('\r', stdout);                            // 回到行首
    std::fwrite(line.data(), 1, line.size(), stdout);    // 覆盖输出
    std::fflush(stdout);                                  // 立即刷新
}




// helper: read SurfData.csv (columns X,Y,Z,u,v,w in SI units, with header)
static std::vector<SamplePoint> read_samples(const string& csv_path) {
    std::vector<SamplePoint> out;
    std::ifstream fin(csv_path);
    if (!fin.is_open()) {
        println("ERROR: could not open CSV " + csv_path);
        return out;
    }
    string line; std::getline(fin, line); // skip header
    ulong line_no = 1ul;
    while (std::getline(fin, line)) {
        line_no++;
        std::stringstream ss(line);
        string token; float vals[6]; int i = 0;
        while (std::getline(ss, token, ',')) { if (i < 6) vals[i++] = (float)atof(token.c_str()); }
        if (i != 6) {
            println("WARNING: malformed line " + to_string(line_no) + " in CSV");
            continue;
        }
        SamplePoint sp; sp.p = float3(vals[0], vals[1], vals[2]); sp.u = float3(vals[3], vals[4], vals[5]);
        out.push_back(sp);
    }
    return out;
}

// helper: return current local time in "YYYY-MM-DD hh:mm:ss" format
static string now_str() {
    using namespace std::chrono;
    auto now = system_clock::now();
    std::time_t tt = system_clock::to_time_t(now);
    std::tm tm;
#if defined(_WIN32)
    if (localtime_s(&tm, &tt) != 0) {
        throw std::runtime_error("Failed to get local time.");
    }
#else
    if (localtime_r(&tt, &tm) == nullptr) {
        throw std::runtime_error("Failed to get local time.");
    }
#endif
    std::stringstream ss;
    ss << std::put_time(&tm, "%F %T"); // %F = YYYY-MM-DD, %T = hh:mm:ss
    return ss.str();
}


void main_setup() {
    println("|-----------------------------------------------------------------------------|");
    println("|                                                                             |");
    println("|      Urban Simulation with WRF bridge by Huanxia Wei for NMIC (CMA)         |");
    println("|                                            Version - 250727 - Draft         |");
    println("|                                                                             |");
    println("|-----------------------------------------------------------------------------|");

    // ---------------------- read conf.txt -----------------------------------
    {
        const std::string conf_path = get_exe_path() + std::string("../../../conf.txt");
        std::ifstream fin(conf_path);
        if (fin.is_open()) conf_used_path = conf_path;

        // trim
        auto trim = [](std::string s) {
            const char* ws = " \t";
            size_t b = s.find_first_not_of(ws);
            size_t e = s.find_last_not_of(ws);
            return (b == std::string::npos) ? std::string() : s.substr(b, e - b + 1);
            };
        // get values
        auto second_val = [](const std::string& rng) {
            size_t c = rng.find(','); size_t r = rng.find(']', c);
            return (float)atof(rng.substr(c + 1, r - c - 1).c_str());
            };

        // helper: remove surrounding quotation marks from a string if present
        auto strip_quotes = [](std::string s) {
            if (s.size() >= 2 && s.front() == '"' && s.back() == '"')
                return s.substr(1, s.size() - 2);
            return s;
            };

        // resolve GPU number
        auto parse_triplet_uint = [&](const std::string& rng, uint& a, uint& b, uint& c) {
            size_t lb = rng.find('[');
            size_t rb = rng.find(']', lb);
            if (lb == std::string::npos || rb == std::string::npos) return; // Fall back to single GPU
            std::string inside = rng.substr(lb + 1, rb - lb - 1);
            std::stringstream ss(inside);
            std::string token;
            uint vals[3] = { a, b, c };
            int i = 0;
            while (std::getline(ss, token, ',') && i < 3) {
                vals[i++] = static_cast<uint>(atoi(trim(token).c_str()));
            }
            if (i == 3) { a = vals[0]; b = vals[1]; c = vals[2]; }
            };

        if (!fin.is_open()) {
            println("WARNING: conf.txt not found, using integrated defaults...");
            caseName = "shanghai";
            si_size = float3(3518.36f, 4438.94f, 1000.0f + z_si_offset);
        }
        else {
            std::string line;
            while (std::getline(fin, line)) {
                size_t cmt = line.find("//"); if (cmt != std::string::npos) line.erase(cmt);
                size_t eq = line.find('=');  if (eq == std::string::npos) continue;

                std::string key = trim(line.substr(0, eq));
                std::string val = trim(line.substr(eq + 1));

                if (key == "casename")        caseName = strip_quotes(val);
                else if (key == "datetime")   datetime = strip_quotes(val);
                else if (key == "downstream_bc") downstream_bc = strip_quotes(val);
                else if (key == "downstream_bc_yaw") downstream_bc_yaw = strip_quotes(val);
                else if (key == "base_height") z_si_offset = (float)atof(val.c_str());
                else if (key == "memory_lbm")  memory = (uint)atoi(val.c_str());
                else if (key == "si_x_cfd")    si_size.x = second_val(val);
                else if (key == "si_y_cfd")    si_size.y = second_val(val);
                else if (key == "si_z_cfd")    si_size.z = second_val(val);
                else if (key == "n_gpu")       parse_triplet_uint(val, Dx, Dy, Dz);
                else if (key == "validation") validation = strip_quotes(val);
            }
            si_size.z += z_si_offset;
            if (!memory) memory = 6000u;

            // Zero card is certainly not allowed
            if (Dx == 0u) Dx = 1u;
            if (Dy == 0u) Dy = 1u;
            if (Dz == 0u) Dz = 1u;

        }
    }

    if (validation != "pass") {
        println("|-----------------------------------------------------------------------------|");
        println("| ERROR: preprocessing validation failed. Computation aborted.                |");
        println("|-----------------------------------------------------------------------------|");
        wait();
        exit(-1);
    }
    else {
        println("| Preprocessing validation passed.                                            |");
    }

    auto fmtf = [](float v, int prec = 2) {
        std::ostringstream os;
        os << std::fixed << std::setprecision(prec) << v;
        return os.str();
        };
    auto fmt_sci = [](float v, int prec = 3) {
        std::ostringstream os;
        os << std::scientific << std::setprecision(prec) << v;
        return os.str();
        };


    // print configurations
    println("| Using configuration deck: " + conf_used_path + " |");
    println("| caseName=" + caseName + ", datetime=" + datetime + "                                    |");
    println("| Height of basement: " + fmtf(z_si_offset) + ", GPU memory allocation: " + to_string(memory) + "                     |");
    println("| si_size [m] = [" + fmtf(si_size.x) + ", " + fmtf(si_size.y) + ", " + fmtf(si_size.z) + "]                                   |");



    println("| Downstream of estimated potential flow is " + downstream_bc + " BC.                            |");
    println("| Yaw between potential flow and surface normal is " + downstream_bc_yaw + " degree.              |");
    println("| GPU domain split Dx,Dy,Dz = " + to_string(Dx) + "," + to_string(Dy) + "," + to_string(Dz) + "                                           |");

    println("|-----------------------------------------------------------------------------|");
    const float lbm_ref_u = 0.5f, si_ref_u = 50.0f;

    const float si_nu = 1.48E-5f, si_rho = 1.225f;

    const uint3 lbm_N = resolution(si_size, memory);
    println("| Grid resolution Nx,Ny,Nz = " + to_string(lbm_N.x) + "," + to_string(lbm_N.y) + "," + to_string(lbm_N.z) + "                                    |");
    units.set_m_kg_s((float)lbm_N.y, lbm_ref_u, 0.1f, si_size.y, si_ref_u, si_rho);

    const float z_off = units.x(z_si_offset);

    float lbm_nu = units.nu(si_nu);
    println("| LBM viscosity = " + fmt_sci(lbm_nu, 6) + "                                                    |");


    // read CSV
    const std::string csv_path = get_exe_path() + std::string("../../../wrfInput/") + caseName + "/SurfData_" + datetime + ".csv";

    auto samples_si = read_samples(csv_path);
    println("| WRF data loaded = " + to_string(samples_si.size()) + "                                                     |");
    if (samples_si.empty()) { println("ERROR: no inlet samples. Aborting."); wait(); exit(-1); }

    // convert samples to LBM units
    const float u_scale = lbm_ref_u / si_ref_u;
    std::vector<SamplePoint> samples; samples.reserve(samples_si.size());
    for (const auto& s : samples_si) { SamplePoint sp; sp.p = float3(units.x(s.p.x), units.x(s.p.y), units.x(s.p.z + z_si_offset)); sp.u = s.u * u_scale; samples.push_back(sp); }


    // lwg multiple GPU
    // const uint Dx = 2u, Dy = 1u, Dz = 1u;
    LBM lbm(lbm_N, Dx, Dy, Dz, lbm_nu);

    // LBM lbm(lbm_N, lbm_nu);   // single GPU mode

    const float3 origin_lbmu = lbm.position(0u, 0u, 0u);   // (0.5,0.5,0.5)
    for (auto& sp : samples) {
        sp.p.x += origin_lbmu.x;
        sp.p.y += origin_lbmu.y;
        sp.p.z += origin_lbmu.z;
    }
    const float z0_lbmu = origin_lbmu.z;

    //const float z0_lbmu = lbm.position(0u, 0u, 0u).z;   

    // ------------------------------- MESH LOADING -------------------------------
    println("|-----------------------------------------------------------------------------|");
    println("| Loading buildings as geometry, meshing...                                   |");

    Mesh* mesh = read_stl(get_exe_path() + std::string("../../../geoData/") + caseName + "/" + caseName + "_with_base.stl");

    println("| Time code: " + now_str() + "                                              |");

    if (!mesh) { println("ERROR: failed to load STL"); wait(); exit(-1); }
    mesh->scale(1.0f); // STL restore here
    const float target_lbm_x = units.x(si_size.x); const float scale_geom = target_lbm_x / mesh->get_bounding_box_size().x; mesh->scale(scale_geom);
    mesh->translate(float3(1.0f - mesh->pmin.x, 1.0f - mesh->pmin.y, 1.0f - mesh->pmin.z));

    println("| Geometry scaled by " + to_string(scale_geom, 4u) + ", voxelizing...                                    |");

    lbm.voxelize_mesh_on_device(mesh);
    println("| Voxelization done.                                                          |");
    println("|-----------------------------------------------------------------------------|");

    println("| Building BC: Connecting to WRF data (single-threading only for draft).      |");

    println("| Time code: " + now_str() + "                                              |");

    // 真三维最邻近插值，不做桶与MLS
    std::function<float3(const float3&)> inlet_velocity;

    inlet_velocity = [&](const float3& pos)->float3 {
        // 地基以下置零
        if (pos.z <= z0_lbmu) {
            return float3(0.0f);
        }

        int   best_i = -1;
        float best_r2 = FLT_MAX;

        // 线性扫描最近样本
        for (size_t i = 0; i < samples.size(); ++i) {
            const auto& sp = samples[i];
            float dx = sp.p.x - pos.x;
            float dy = sp.p.y - pos.y;
            float dz = sp.p.z - pos.z;
            float r2 = dx * dx + dy * dy + dz * dz;
            if (r2 < best_r2) {
                best_r2 = r2;
                best_i = static_cast<int>(i);
            }
        }

        if (best_i >= 0) {
            return samples[static_cast<size_t>(best_i)].u;
        }
        // 理论上不会到此。给出安全回退
        return float3(0.0f);
        };



    // PML nLayers
    const uint Nx = lbm.get_Nx(), Ny = lbm.get_Ny(), Nz = lbm.get_Nz();
    const uint N_ABSORB = 10u;

    std::atomic<ulong> inlet_face_count(0), outlet_face_count(0);
    std::atomic<ulong> inlet_grid_count(0), outlet_grid_count(0);

    // 进度计数：轻节点（体内、底面、出口）与重节点（入口）
    std::atomic<ulong> processed_light(0), processed_heavy(0);
    std::atomic<ulong> tot_light(0), tot_heavy(0);

    parallel_for(lbm.get_N(), [&](ulong n) {
        uint x = 0, y = 0, z = 0;
        lbm.coordinates(n, x, y, z);

        if (z == 0u) { tot_light++; return; }

        uint dist_out = 0u; bool outlet = false;
        if (downstream_bc == "+y") { dist_out = Ny - 1u - y; outlet = (dist_out < N_ABSORB); }
        else if (downstream_bc == "-y") { dist_out = y; outlet = (dist_out < N_ABSORB); }
        else if (downstream_bc == "+x") { dist_out = Nx - 1u - x; outlet = (dist_out < N_ABSORB); }
        else if (downstream_bc == "-x") { dist_out = x; outlet = (dist_out < N_ABSORB); }

        bool inlet = ((x == 0u || x == Nx - 1u ||
            y == 0u || y == Ny - 1u ||
            z == Nz - 1u) && !outlet);
        if (inlet) tot_heavy++; else tot_light++;
        });
    const ulong TOT_LIGHT = tot_light.load();
    const ulong TOT_HEAVY = tot_heavy.load();
    std::vector<ulong> heavy_nodes(TOT_HEAVY);
    std::atomic<ulong> heavy_write_pos{ 0 };

    // 进度采样线程：每 100 ms 覆盖同一行输出
    std::atomic<bool> progress_stop{ false };
    std::thread progress_thread([&] {
        using namespace std::chrono;
        while (!progress_stop.load(std::memory_order_relaxed)) {
            double light_pct = TOT_LIGHT ? 100.0 * double(processed_light.load()) / double(TOT_LIGHT) : 100.0;
            double heavy_pct = TOT_HEAVY ? 100.0 * double(processed_heavy.load()) / double(TOT_HEAVY) : 100.0;
            print_progress_inline(light_pct, heavy_pct);                  // 原地刷新
            std::this_thread::sleep_for(std::chrono::milliseconds(100));  // 周期采样
        }
        print_progress_inline(100.0, 100.0, true);   // 强制最后一帧
        std::fputc('\n', stdout);                    // 收尾换行 让后续日志从新行开始
        std::fflush(stdout);
        });

    parallel_for(lbm.get_N(), [&](ulong n) { uint x = 0, y = 0, z = 0; lbm.coordinates(n, x, y, z); const float3 pos = lbm.position(x, y, z);

    if (z == 0u) {
        lbm.flags[n] = TYPE_S;
        ++processed_light;
        return;

    }

    // Determine outlet from potential flow downstream defined in deck
    uint dist_out = 0u;              // AML distance
    bool outlet = false;
    if (downstream_bc == "+y") {
        dist_out = Ny - 1u - y;
        outlet = (dist_out < N_ABSORB);
    }
    else if (downstream_bc == "-y") {
        dist_out = y;
        outlet = (dist_out < N_ABSORB);
    }
    else if (downstream_bc == "+x") {
        dist_out = Nx - 1u - x;
        outlet = (dist_out < N_ABSORB);
    }
    else if (downstream_bc == "-x") {
        dist_out = x;
        outlet = (dist_out < N_ABSORB);
    }


    // All others are inlet
    bool inlet = ((x == 0u || x == Nx - 1u ||
        y == 0u || y == Ny - 1u ||
        z == Nz - 1u) && !outlet);

    if (inlet) {
        lbm.flags[n] = TYPE_E; // 仅标记入口，插值放到第二轮
        ulong idx = heavy_write_pos.fetch_add(1, std::memory_order_relaxed);
#ifndef NDEBUG
        if (idx >= TOT_HEAVY) {
            println("ERROR: heavy_nodes overflow");
        }
#endif
        if (idx < TOT_HEAVY) heavy_nodes[idx] = n;
    }

    else if (outlet) {
        lbm.flags[n] = TYPE_E;

        const float w = float(dist_out + 1u) / float(N_ABSORB);  // w ∈ (0,1]
        lbm.rho[n] = 1.0f;                                       // 最外层维持常压
        lbm.u.x[n] *= w;                                         // 速度递减
        lbm.u.y[n] *= w;
        lbm.u.z[n] *= w;

        outlet_face_count++;
        outlet_grid_count++;
    }

    if (!inlet) ++processed_light; // Heavy 在第二轮并行里再累计
        });

    assert(inlet_velocity && "inlet_velocity not initialized!");
    // 第二轮并行：对入口节点执行插值（规则网格 tricubic；否则 NN）
    if (TOT_HEAVY > 0) {
        parallel_for(TOT_HEAVY, [&](ulong i) {
            ulong n = heavy_nodes[i];
            uint x = 0, y = 0, z = 0;
            lbm.coordinates(n, x, y, z);
            const float3 pos = lbm.position(x, y, z);

            float3 u = inlet_velocity(pos);     // 仍然是原来的最近邻
            lbm.u.x[n] = u.x;
            lbm.u.y[n] = u.y;
            lbm.u.z[n] = u.z;

            inlet_face_count++;
            inlet_grid_count++;
            ++processed_heavy;
            });
    }

    // 并行 Heavy 完成后关闭进度线程
    progress_stop.store(true, std::memory_order_relaxed);
    progress_thread.join();


    println("| inlet grid count: " + to_string(inlet_grid_count.load()) + "                                     |");
    println("| outlet grid count: " + to_string(outlet_grid_count.load()) + "                                    |");
    println("| Boundary initialization complete.                                           |");
    println("| Time code: " + now_str() + "                                              |");

    // ------------------------------------------------------------------- graphics & run --------------------------------------------------------------------
    lbm.graphics.visualization_modes = VIS_FLAG_SURFACE | VIS_Q_CRITERION;

    const ulong lbm_T = 100001ull;
    const uint  vtk_dt = 20000u;        // export VTK every 20 time steps
    const std::string vtk_dir = get_exe_path() + std::string("../../../caseData/") + caseName + "/" + datetime + "_raw_";
    //const string vtk_dir = get_exe_path() + "vtk/"; // ensure this directory exists beforehand

#if defined(GRAPHICS) && !defined(INTERACTIVE_GRAPHICS)
    // Camera
    lbm.graphics.set_camera_free(
        float3(0.6f * Nx, -0.7f * Ny, 2.2f * Nz), // upstream & elevated
        -45.0f,                               // yaw
        30.0f,                                // pitch
        80.0f);                               // FOV

    lbm.run(0u, lbm_T); // initialize fields and graphics buffers
    while (lbm.get_t() < lbm_T) {
        // ------------------ off‑screen PNG rendering (optional video) ------------------
        if (lbm.graphics.next_frame(lbm_T, 1.0f)) {
            lbm.graphics.write_frame(); // default path: exe_dir/export/frame_#####.png
        }

        // ------------------ synchronous VTK output ------------------
        if (lbm.get_t() % vtk_dt == 0u) {
            const string ts = to_string(lbm.get_t());
            // velocity (vector field)
            lbm.u.write_device_to_vtk(vtk_dir, true);
            // density as proxy for pressure (p = c_s^2 * (rho-1) can be computed in ParaView)
            lbm.rho.write_device_to_vtk(vtk_dir, true);
        }

        lbm.run(1u, lbm_T);
    }
    println("| Task finished: " + now_str() + "                                                |");

#else // GRAPHICS + INTERACTIVE or pure CLI
    while (lbm.get_t() < lbm_T) {
        if (lbm.get_t() % vtk_dt == 0u) {
            const string vtk_file = vtk_dir + "step_" + to_string(lbm.get_t(), 5u) + ".vtk";
            lbm.write_vtk(vtk_file, true, true);
        }
        lbm.run(1u, lbm_T);
    }
#endif
}
